{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyWC: Membrane Interface Analysis with Willard-Chandler Surfaces","text":"<p>pyWC is a high-performance Python toolkit for analyzing membrane interfaces in molecular dynamics simulations. It computes intrinsic density surfaces using the Willard-Chandler method, enabling quantitative analysis of membrane surfaces, thickness profiles, and bending rigidity. The package is optimized for large biological membrane systems with multiple computational backends (CPU/GPU).</p>"},{"location":"#main-contributions","title":"Main Contributions","text":""},{"location":"#1-command-line-tools-for-membrane-analysis","title":"1. Command-Line Tools for Membrane Analysis","text":"<p>pyWC provides ready-to-use scripts in <code>./scripts/</code> for common membrane analysis tasks:</p> <ul> <li><code>pywc-wc-area</code>: Compute surface area and thickness profiles over trajectories</li> <li><code>pywc-bending-rigidity</code>: Estimate bending modulus from surface fluctuations</li> <li><code>pywc-compare-wc-backends</code>: Benchmark different computational backends</li> </ul> <p>These tools enable immediate analysis without writing custom Python code.</p>"},{"location":"#2-optimized-willard-chandler-implementation","title":"2. Optimized Willard-Chandler Implementation","text":"<p>Significant performance improvements over the original pytim implementation:</p> <ul> <li>~35x faster KDE evaluation through optimized C++ implementation with OpenMP</li> <li>GPU acceleration via CuPy for large membrane systems (&gt;10k atoms)</li> <li>10-20x faster system centering with parallel algorithms</li> <li>Efficient memory management for trajectory processing</li> </ul>"},{"location":"#3-membrane-specific-features","title":"3. Membrane-Specific Features","text":"<ul> <li>Thickness profiles: Compute local membrane thickness along interface normals</li> <li>Bending rigidity: Extract mechanical properties from surface fluctuations</li> <li>Surface curvature: Analyze membrane deformations and undulations</li> <li>Interface tracking: Maintain surface continuity across MD frames</li> </ul>"},{"location":"#about-this-fork","title":"About This Fork","text":"<p>This project is a specialized fork of pytim by Marcello Sega and collaborators. While pytim provides a comprehensive suite of interfacial analysis methods (ITIM, GITIM, SASA, Willard-Chandler, and DBSCAN), pyWC focuses exclusively on the Willard-Chandler method optimized for membrane analysis.</p> <p>Upstream Project: Marcello-Sega/pytim</p> <p>Original Publication: Sega, M., Fabian, B., &amp; Jedlovszky, P. (2018). Pytim: A python package for the interfacial analysis of molecular simulations. Journal of Computational Chemistry, 39(25), 2118-2125. DOI: 10.1002/jcc.25384</p>"},{"location":"#scientific-background","title":"Scientific Background","text":"<p>The Willard-Chandler method identifies intrinsic membrane surfaces by:</p> <ol> <li>Computing a smooth density field from membrane atoms via Gaussian kernel density estimation (KDE)</li> <li>Extracting the isosurface at critical density using marching cubes algorithm</li> <li>Providing a triangulated surface representation for geometric and mechanical analysis</li> </ol> <p>This approach is particularly powerful for biological membranes where:</p> <ul> <li>Thermal fluctuations create complex, non-planar surfaces</li> <li>Local thickness variations reflect membrane composition and interactions</li> <li>Surface curvature and undulations encode mechanical properties</li> </ul> <p>Reference: Willard, A. P., &amp; Chandler, D. (2010). Instantaneous liquid interfaces. The Journal of Physical Chemistry B, 114(5), 1954-1958. DOI: 10.1021/jp909219k</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#multi-backend-performance","title":"Multi-Backend Performance","text":"<ul> <li>CPU (C++): OpenMP-parallelized pybind11 extensions (~35x speedup)</li> <li>GPU (CUDA): CuPy implementation with custom CUDA kernels for large membranes</li> <li>Python: Pure NumPy/SciPy fallback for testing</li> </ul>"},{"location":"#membrane-analysis-capabilities","title":"Membrane Analysis Capabilities","text":"<ul> <li>Surface extraction: Compute intrinsic membrane surfaces from lipid density fields</li> <li>Thickness profiles: Calculate local membrane thickness with spatial resolution</li> <li>Surface area: Track membrane area changes during phase transitions or pore formation</li> <li>Bending rigidity: Estimate mechanical properties from surface undulation spectra</li> <li>Curvature analysis: Quantify local and global membrane deformations</li> <li>Trajectory processing: Analyze entire MD simulations with frame-to-frame continuity</li> </ul>"},{"location":"#output-formats","title":"Output Formats","text":"<ul> <li>VTK: For visualization in ParaView, VMD</li> <li>Wavefront OBJ: For 3D graphics software (Blender, etc.)</li> <li>Gaussian Cube: For quantum chemistry packages</li> <li>PDB: For molecular visualization</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#command-line-analysis","title":"Command-Line Analysis","text":"<p>For quick membrane analysis without coding:</p> <pre><code># Compute membrane surface area and thickness over trajectory\npywc-wc-area -s membrane.tpr -x trajectory.xtc \\\n    --selection-file atoms.txt \\\n    --alpha 3.0 --mesh 2.5 \\\n    -b 0 -e 1000 --step 10\n\n# Estimate bending rigidity\npywc-bending-rigidity -s membrane.tpr -x trajectory.xtc \\\n    --selection-file atoms.txt \\\n    --alpha 3.0 --mesh 2.5\n</code></pre> <p>See the CLI Tools Guide for detailed usage examples.</p>"},{"location":"#python-api-for-membrane-analysis","title":"Python API for Membrane Analysis","text":"<pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load membrane simulation\nu = mda.Universe(\"membrane.tpr\", \"trajectory.xtc\")\n\n# Select lipid headgroups for surface calculation\nlipids = u.select_atoms(\"resname DPPC DOPC and name PO4\")\n\n# Compute Willard-Chandler surface\nwc = WillardChandler(\n    u,\n    group=lipids,\n    alpha=3.0,           # Gaussian width (\u00c5)\n    mesh=2.5,            # Grid spacing (\u00c5)\n    centered=True,       # Center membrane in box\n    surface_backend='cpp'  # Use optimized C++ backend\n)\n\n# Analyze membrane properties\nprint(f\"Membrane surface area: {wc.surface_area:.2f} \u0172\")\nprint(f\"Average thickness: {wc.thickness_profile.mean():.2f} \u00c5\")\n\n# Export for visualization\nwc.writevtk.surface(\"membrane_surface.vtk\")  # ParaView\nwc.writeobj(\"membrane_surface.obj\")          # Blender\nwc.writecube(\"density.cube\")                 # VMD\n</code></pre>"},{"location":"#gpu-acceleration","title":"GPU Acceleration","text":"<pre><code># Use GPU backend for large systems\nwc = WillardChandler(\n    u,\n    group=group,\n    alpha=3.0,\n    mesh=2.0,\n    surface_backend='cupy',  # GPU backend\n    enable_timing=True\n)\n\n# Check performance\nprint(f\"Computation time: {wc.get_timing():.4f} s\")\n</code></pre>"},{"location":"#trajectory-analysis","title":"Trajectory Analysis","text":"<pre><code># Process entire trajectory\nareas = []\nfor ts in u.trajectory:\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n\n# Analyze results\nimport numpy as np\nprint(f\"Mean area: {np.mean(areas):.2f} \u00b1 {np.std(areas):.2f} \u0172\")\n</code></pre>"},{"location":"#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Real-world membrane analysis using <code>pywc-wc-area</code>:</p> System Atoms Backend Time (ms) Speedup vs Python GOLO/GOLH interdigitated membrane 105,000 Python 427 1.0x GOLO/GOLH interdigitated membrane 105,000 C++ (cpu) 25 17.1x GOLO/GOLH interdigitated membrane 105,000 GPU (cupy) 20 21.4x <p>Benchmarks measured with the <code>pywc-wc-area</code> command-line tool on a large biological membrane system (\u03b1=3.0 \u00c5, mesh=2.5 \u00c5)</p> <p>What's measured: Complete Willard-Chandler surface computation per frame:</p> <ol> <li>System centering and grid preparation (<code>prepare_box</code>)</li> <li>KDE density field evaluation (<code>define_cluster_group</code>) - most compute-intensive step</li> <li>Marching cubes isosurface extraction (<code>compute_surface</code>)</li> </ol> <p>Time reported is mean per-frame (excluding first 2 frames to remove initialization overhead).</p> <p>Key insight: The C++ backend provides ~17x speedup for production membrane analysis, while GPU provides ~21x speedup for large systems.</p>"},{"location":"#parameter-selection","title":"Parameter Selection","text":"<ul> <li><code>alpha</code> (Gaussian width): Typically 2-4 \u00c5. Smaller values = sharper surfaces, larger values = smoother surfaces</li> <li><code>mesh</code> (grid spacing): Typically 1-3 \u00c5. Smaller values = more detail but slower computation</li> <li><code>centered</code>: Set <code>True</code> to avoid periodic boundary artifacts</li> </ul>"},{"location":"#backend-selection","title":"Backend Selection","text":"Backend When to Use <code>'cpp'</code> Default for most applications (best CPU performance) <code>'cupy'</code> Large systems (&gt;10k atoms) with NVIDIA GPU <code>'python'</code> Testing, debugging, or when C++ compilation fails"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Membrane biophysics: Lipid bilayer surface characterization and thickness analysis</li> <li>Phase transitions: Track membrane properties during gel-to-fluid transitions</li> <li>Protein-membrane interactions: Quantify membrane deformation around proteins</li> <li>Pore formation: Monitor surface area and thickness changes</li> <li>Mechanical properties: Extract bending rigidity from thermal fluctuations</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start? Check out the Installation Guide and Quick Start Tutorial.</p> <p>For command-line tools, see the CLI Tools Guide.</p>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository: octupole/pyWC</li> <li>Report Issues: GitHub Issues</li> <li>Contribute: See our Contributing Guide</li> <li>Contact: Massimo Marchi (massimo@octupole.org)</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use pyWC in your research, please cite both this fork and the original pytim paper. See the Citation Guide for details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 (GPL-3.0) - the same license as the upstream pytim project.</p>"},{"location":"citation/","title":"Citation","text":"<p>If you use pyWC in your research, please cite both this fork and the original pytim paper.</p>"},{"location":"citation/#citing-pywc","title":"Citing pyWC","text":""},{"location":"citation/#bibtex-entry","title":"BibTeX Entry","text":"<pre><code>@software{pywc2025,\n  author = {Marchi, Massimo},\n  title = {pyWC: Willard-Chandler Surface Analysis Toolkit},\n  year = {2025},\n  url = {https://github.com/octupole/pyWC},\n  version = {1.0.4+wc},\n  note = {Fork of pytim focused on Willard-Chandler method with performance enhancements}\n}\n</code></pre>"},{"location":"citation/#in-text","title":"In Text","text":"<p>Marchi, M. (2025). pyWC: Willard-Chandler Surface Analysis Toolkit (Version 1.0.4+wc) [Computer software]. https://github.com/octupole/pyWC</p>"},{"location":"citation/#citing-original-pytim","title":"Citing Original pytim","text":"<p>You must also cite the original pytim paper:</p> <pre><code>@article{pytim2018,\n  author = {Sega, Marcello and Fabian, Balazs and Jedlovszky, P\u00e1l},\n  title = {Pytim: A python package for the interfacial analysis of molecular simulations},\n  journal = {Journal of Computational Chemistry},\n  volume = {39},\n  number = {25},\n  pages = {2118-2125},\n  year = {2018},\n  doi = {10.1002/jcc.25384},\n  url = {https://doi.org/10.1002/jcc.25384}\n}\n</code></pre>"},{"location":"citation/#in-text_1","title":"In Text","text":"<p>Sega, M., Fabian, B., &amp; Jedlovszky, P. (2018). Pytim: A python package for the interfacial analysis of molecular simulations. Journal of Computational Chemistry, 39(25), 2118-2125. https://doi.org/10.1002/jcc.25384</p>"},{"location":"citation/#citing-willard-chandler-method","title":"Citing Willard-Chandler Method","text":"<p>For the original Willard-Chandler method:</p> <pre><code>@article{willard2010,\n  author = {Willard, Adam P. and Chandler, David},\n  title = {Instantaneous liquid interfaces},\n  journal = {The Journal of Physical Chemistry B},\n  volume = {114},\n  number = {5},\n  pages = {1954-1958},\n  year = {2010},\n  doi = {10.1021/jp909219k},\n  url = {https://doi.org/10.1021/jp909219k}\n}\n</code></pre>"},{"location":"citation/#in-text_2","title":"In Text","text":"<p>Willard, A. P., &amp; Chandler, D. (2010). Instantaneous liquid interfaces. The Journal of Physical Chemistry B, 114(5), 1954-1958. https://doi.org/10.1021/jp909219k</p>"},{"location":"citation/#complete-citation-example","title":"Complete Citation Example","text":"<p>In your Methods section:</p> <p>Surface analysis was performed using pyWC v1.0.4+wc (Marchi, 2025), a performance-optimized fork of pytim (Sega et al., 2018), implementing the Willard-Chandler method (Willard &amp; Chandler, 2010) for computing intrinsic density surfaces.</p> <p>In your References:</p> <pre><code>Marchi, M. (2025). pyWC: Willard-Chandler Surface Analysis Toolkit\n    (Version 1.0.4+wc) [Computer software]. https://github.com/octupole/pyWC\n\nSega, M., Fabian, B., &amp; Jedlovszky, P. (2018). Pytim: A python package\n    for the interfacial analysis of molecular simulations. Journal of\n    Computational Chemistry, 39(25), 2118-2125.\n    https://doi.org/10.1002/jcc.25384\n\nWillard, A. P., &amp; Chandler, D. (2010). Instantaneous liquid interfaces.\n    The Journal of Physical Chemistry B, 114(5), 1954-1958.\n    https://doi.org/10.1021/jp909219k\n</code></pre>"},{"location":"citation/#github-citation-feature","title":"GitHub Citation Feature","text":"<p>GitHub automatically generates citations from the <code>CITATION.cff</code> file. On the pyWC repository page, click the \"Cite this repository\" button in the sidebar to get formatted citations.</p>"},{"location":"citation/#additional-citations","title":"Additional Citations","text":""},{"location":"citation/#for-gpu-implementation","title":"For GPU Implementation","text":"<p>If you specifically used the GPU backend:</p> <pre><code>@software{cupy,\n  author = {% raw %}{{CuPy Development Team}}{% endraw %},\n  title = {CuPy: NumPy \\&amp; SciPy for GPU},\n  year = {2023},\n  url = {https://cupy.dev/},\n}\n</code></pre>"},{"location":"citation/#for-mdanalysis","title":"For MDAnalysis","text":"<p>If using MDAnalysis for trajectory handling:</p> <pre><code>@article{mdanalysis2016,\n  author = {Gowers, Richard J. and Linke, Max and Barnoud, Jonathan and\n            Reddy, Tyler J. E. and Melo, Manuel N. and Seyler, Sean L. and\n            Doma\u0144ski, Jan and Dotson, David L. and Buchoux, S\u00e9bastien and\n            Kenney, Ian M. and Beckstein, Oliver},\n  title = {% raw %}{{MDAnalysis}: A Python Package for the Rapid Analysis of\n           Molecular Dynamics Simulations}{% endraw %},\n  journal = {Proceedings of the 15th Python in Science Conference},\n  pages = {98-105},\n  year = {2016},\n  doi = {10.25080/Majora-629e541a-00e}\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":""},{"location":"citation/#in-your-manuscript","title":"In Your Manuscript","text":"<p>Consider adding an acknowledgment:</p> <p>We thank Marcello Sega and collaborators for developing the original pytim package, upon which this work builds. We also acknowledge the developers of MDAnalysis, NumPy, SciPy, and scikit-image for providing essential software infrastructure.</p>"},{"location":"citation/#questions","title":"Questions?","text":"<p>For citation questions or if you'd like to discuss how pyWC was used in your research, please contact:</p> <p>Massimo Marchi - Email: massimo@octupole.org - GitHub: @octupole</p>"},{"location":"citation/#related-software","title":"Related Software","text":"<p>If you used other tools in your analysis pipeline, consider citing:</p> <ul> <li>ParaView: For visualization</li> <li>VMD: For molecular visualization</li> <li>NumPy/SciPy: For numerical computing</li> <li>scikit-image: For marching cubes algorithm</li> </ul>"},{"location":"cli-tools/","title":"Command-Line Tools","text":"<p>pyWC provides production-ready command-line tools for membrane analysis. These tools require no Python programming and can be integrated into analysis pipelines or batch processing workflows.</p>"},{"location":"cli-tools/#overview","title":"Overview","text":"Tool Purpose Output <code>pywc-wc-area</code> Compute surface area and thickness profiles CSV files with per-frame statistics <code>pywc-bending-rigidity</code> Estimate bending modulus from fluctuations Bending rigidity value <code>pywc-compare-wc-backends</code> Benchmark CPU vs GPU backends Performance comparison"},{"location":"cli-tools/#pywc-wc-area","title":"pywc-wc-area","text":"<p>The main tool for membrane surface area and thickness analysis across MD trajectories.</p>"},{"location":"cli-tools/#quick-start","title":"Quick Start","text":"<pre><code>pywc-wc-area -s membrane.tpr -x trajectory.xtc \\\n    --selection-file atoms.txt \\\n    --alpha 3.0 --mesh 2.5 \\\n    --backend cpp \\\n    -b 0 -e 10000 --step 10\n</code></pre>"},{"location":"cli-tools/#key-features","title":"Key Features","text":"<ul> <li>Dual outputs: Surface area per frame + averaged thickness map</li> <li>Multiple backends: Python, C++ (CPU), or GPU (CuPy)</li> <li>Time/frame selection: Analyze specific portions of trajectories</li> <li>Automatic centering: Handle periodic boundaries correctly</li> <li>Performance timing: Built-in benchmarking</li> </ul>"},{"location":"cli-tools/#output-files","title":"Output Files","text":"<ol> <li>Area file (<code>willard_chandler_area.csv</code>): Per-frame surface area statistics</li> <li>Thickness file (<code>willard_chandler_thickness.csv</code>): Spatially-resolved thickness map</li> </ol>"},{"location":"cli-tools/#command-line-options","title":"Command-Line Options","text":""},{"location":"cli-tools/#required-arguments","title":"Required Arguments","text":"<pre><code>-s, --topology FILE        # Topology file (TPR, PSF, GRO, etc.)\n-x, --trajectory FILE      # Trajectory file (XTC, TRR, DCD, etc.)\n</code></pre>"},{"location":"cli-tools/#atom-selection","title":"Atom Selection","text":"<pre><code>--selection \"EXPR\"         # MDAnalysis selection string\n--selection-file FILE      # Read selection from text file (recommended)\n--selection-env VAR        # Read selection from environment variable\n</code></pre> <p>Example selection file (<code>atoms.txt</code>): <pre><code>resname DPPC DOPC and name PO4 C31 C32\n</code></pre></p>"},{"location":"cli-tools/#willard-chandler-parameters","title":"Willard-Chandler Parameters","text":"<pre><code>--alpha FLOAT              # Gaussian kernel width (\u00c5) [default: 3.0]\n--mesh FLOAT               # Grid spacing (\u00c5) [default: 2.0]\n--density-cutoff FLOAT     # Absolute density threshold (overrides --density-level)\n--density-level FLOAT      # Relative density level [0-2] [default: 1.0]\n                          #   0 = minimum density\n                          #   1 = midpoint (typical)\n                          #   2 = maximum density\n</code></pre> <p>Parameter Selection</p> <ul> <li><code>alpha</code>: Use 2.5-3.5 \u00c5 for lipid membranes, 3.0-4.0 \u00c5 for protein surfaces</li> <li><code>mesh</code>: Use 2.0-2.5 \u00c5 for most applications (balance between accuracy and speed)</li> <li><code>density-level</code>: Use 1.0 for typical liquid/vapor interfaces</li> </ul>"},{"location":"cli-tools/#backend-selection","title":"Backend Selection","text":"<pre><code>--backend {cpu,cpp,cupy,gpu,python}\n                          # Surface computation backend\n                          #   cpp/cpu: C++ with OpenMP (recommended)\n                          #   cupy/gpu: GPU acceleration (requires CuPy)\n                          #   python: Pure Python (testing only)\n</code></pre>"},{"location":"cli-tools/#trajectory-control","title":"Trajectory Control","text":"<pre><code>--start INDEX             # First frame index (inclusive)\n--stop INDEX              # Last frame index (exclusive)\n-b, --start-time TIME     # Start time in picoseconds\n-e, --end-time TIME       # End time in picoseconds\n--step N                  # Analyze every Nth frame [default: 1]\n</code></pre>"},{"location":"cli-tools/#thickness-analysis","title":"Thickness Analysis","text":"<pre><code>--grid-size N             # XY grid bins for thickness map [default: 20]\n                          # Set to 0 to disable thickness calculation\n--center                  # Center analysis group before evaluation\n                          # RECOMMENDED for membrane systems\n</code></pre>"},{"location":"cli-tools/#output-control","title":"Output Control","text":"<pre><code>-o, --output FILE         # CSV file for area data\n                          # [default: willard_chandler_area.csv]\n--thickness-output FILE   # CSV file for thickness map\n                          # [default: willard_chandler_thickness.csv]\n</code></pre>"},{"location":"cli-tools/#performance-options","title":"Performance Options","text":"<pre><code>--enable-timing           # Enable detailed timing\n--print-timing            # Print timing breakdown at end\n--skip-frames N           # Skip first N frames in timing stats [default: 2]\n--no-autoassign           # Disable automatic surface recomputation\n</code></pre>"},{"location":"cli-tools/#example-1-basic-membrane-analysis","title":"Example 1: Basic Membrane Analysis","text":"<p>Analyze a DPPC membrane over the entire trajectory:</p> <pre><code># Create selection file\necho \"resname DPPC and name PO4\" &gt; dppc_headgroups.txt\n\n# Run analysis with C++ backend\npywc-wc-area \\\n    -s dppc_membrane.tpr \\\n    -x production.xtc \\\n    --selection-file dppc_headgroups.txt \\\n    --alpha 3.0 \\\n    --mesh 2.5 \\\n    --backend cpp \\\n    --center \\\n    -o dppc_area.csv \\\n    --thickness-output dppc_thickness.csv\n</code></pre> <p>Output: <pre><code>frame      1 time       10.0 ps \u2192 area    15234.45 \u0172 (plane    16000.00 \u0172)\nframe      2 time       20.0 ps \u2192 area    15198.32 \u0172 (plane    16000.00 \u0172)\n...\nTotal time: 25.34 ms (average per frame, excluding first 2 frame(s))\n\nCompleted. Area statistics (\u0172): mean=15216.78, std=45.23, min=15098.12, max=15334.56\nPer-frame data saved to dppc_area.csv\nThickness grid written to dppc_thickness.csv (mean thickness 38.4 \u00c5)\nUpper surface roughness: mean RMS 2.15 \u00c5, mean P-V 8.73 \u00c5\nLower surface roughness: mean RMS 2.08 \u00c5, mean P-V 8.21 \u00c5\n</code></pre></p>"},{"location":"cli-tools/#example-2-time-window-selection","title":"Example 2: Time Window Selection","text":"<p>Analyze only the equilibrated portion (50-100 ns):</p> <pre><code>pywc-wc-area \\\n    -s system.tpr \\\n    -x trajectory.xtc \\\n    --selection-file selection.txt \\\n    --alpha 3.0 \\\n    --mesh 2.0 \\\n    -b 50000 \\\n    -e 100000 \\\n    --step 10 \\\n    --backend cpp\n</code></pre>"},{"location":"cli-tools/#example-3-gpu-acceleration-for-large-systems","title":"Example 3: GPU Acceleration for Large Systems","text":"<p>Use GPU backend for a system with &gt;100k atoms:</p> <pre><code>pywc-wc-area \\\n    -s large_membrane.tpr \\\n    -x trajectory.xtc \\\n    --selection-file lipids.txt \\\n    --alpha 3.0 \\\n    --mesh 2.5 \\\n    --backend cupy \\\n    --center \\\n    --enable-timing \\\n    --print-timing\n</code></pre>"},{"location":"cli-tools/#example-4-custom-density-threshold","title":"Example 4: Custom Density Threshold","text":"<p>Use a specific density cutoff instead of relative level:</p> <pre><code>pywc-wc-area \\\n    -s system.tpr \\\n    -x trajectory.xtc \\\n    --selection-file atoms.txt \\\n    --alpha 3.0 \\\n    --mesh 2.0 \\\n    --density-cutoff 0.015 \\\n    --backend cpp\n</code></pre>"},{"location":"cli-tools/#example-5-high-resolution-thickness-map","title":"Example 5: High-Resolution Thickness Map","text":"<p>Generate a detailed thickness map with fine spatial resolution:</p> <pre><code>pywc-wc-area \\\n    -s membrane.tpr \\\n    -x trajectory.xtc \\\n    --selection-file headgroups.txt \\\n    --alpha 3.0 \\\n    --mesh 2.0 \\\n    --grid-size 50 \\\n    --center \\\n    --backend cpp \\\n    --thickness-output thickness_highres.csv\n</code></pre>"},{"location":"cli-tools/#understanding-the-outputs","title":"Understanding the Outputs","text":""},{"location":"cli-tools/#area-output-csv","title":"Area Output CSV","text":"<p>The area CSV file contains per-frame statistics:</p> Column Description <code>frame</code> Frame number <code>time_ps</code> Simulation time (ps) <code>area_angstrom2</code> Willard-Chandler surface area (\u0172) <code>box_x</code>, <code>box_y</code>, <code>box_z</code> Simulation box dimensions (\u00c5) <code>plane_area</code> Projected XY plane area (\u0172) <code>density_cutoff</code> Density threshold used for isosurface <code>alpha</code> Gaussian width parameter <code>mesh</code> Grid spacing used <code>upper_rms</code>, <code>lower_rms</code> RMS roughness of upper/lower surfaces <code>upper_peak_to_valley</code>, <code>lower_peak_to_valley</code> Peak-to-valley roughness <p>Example: <pre><code>frame,time_ps,area_angstrom2,box_x,box_y,box_z,plane_area,density_cutoff,alpha,mesh,upper_rms,lower_rms,upper_peak_to_valley,lower_peak_to_valley\n1,10.0,15234.45,80.0,80.0,100.0,6400.0,0.0145,3.0,2.5,2.15,2.08,8.73,8.21\n2,20.0,15198.32,80.1,79.9,100.1,6399.99,0.0145,3.0,2.5,2.18,2.11,8.91,8.45\n</code></pre></p>"},{"location":"cli-tools/#thickness-output-csv","title":"Thickness Output CSV","text":"<p>The thickness CSV file contains a spatially-resolved thickness map:</p> Column Description <code>x</code> X coordinate of grid cell center (\u00c5) <code>y</code> Y coordinate of grid cell center (\u00c5) <code>thickness</code> Local membrane thickness (\u00c5) <p>Example: <pre><code>x,y,thickness\n2.0,2.0,38.42\n2.0,6.0,38.67\n2.0,10.0,37.89\n...\n</code></pre></p> <p>This can be visualized as a heatmap or contour plot:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load thickness map\ndf = pd.read_csv('willard_chandler_thickness.csv')\n\n# Pivot for heatmap\ngrid = df.pivot(index='x', columns='y', values='thickness')\n\n# Plot\nplt.figure(figsize=(10, 8))\nplt.imshow(grid, cmap='viridis', origin='lower', aspect='auto')\nplt.colorbar(label='Thickness (\u00c5)')\nplt.xlabel('Y (\u00c5)')\nplt.ylabel('X (\u00c5)')\nplt.title('Membrane Thickness Map')\nplt.savefig('thickness_map.png', dpi=300)\n</code></pre>"},{"location":"cli-tools/#performance-considerations","title":"Performance Considerations","text":""},{"location":"cli-tools/#backend-selection_1","title":"Backend Selection","text":"<p>For a 105,000 atom GOLO/GOLH membrane system:</p> Backend Time per frame Speedup Python 427 ms 1.0x C++ (CPU) 25 ms 17.1x GPU (CuPy) 20 ms 21.4x <p>What is being measured:</p> <p>The timing captures the complete Willard-Chandler surface computation per frame, including:</p> <ol> <li><code>prepare_box()</code>: System centering and density field grid preparation</li> <li><code>define_cluster_group()</code>: KDE computation - evaluating Gaussian kernels at all grid points</li> <li><code>compute_surface()</code>: Marching cubes isosurface extraction and area calculation</li> </ol> <p>These timings are automatically collected by the script when using the built-in timing system:</p> <pre><code># From compute_willard_chandler_area.py, lines 354-364\ninterface = pywc.WillardChandler(\n    universe,\n    group=analysis_group,\n    alpha=args.alpha,\n    mesh=args.mesh,\n    centered=args.center,\n    density_cutoff=args.density_cutoff,\n    autoassign=args.no_autoassign,\n    surface_backend=args.backend,\n    centering_backend='cpu',\n    enable_timing=True,  # Enables automatic timing\n)\n</code></pre> <p>The reported time is the mean per-frame computation time (excluding the first 2 frames to remove initialization overhead):</p> <pre><code># From compute_willard_chandler_area.py, lines 518-526\ntimings = interface.get_detailed_timings(skip_frames=args.skip_frames)\nif timings and 'total' in timings:\n    stats = timings['total']\n    if args.skip_frames &gt; 0:\n        print(f\"Total time: {stats['mean']*1000:.2f} ms \"\n              f\"(average per frame, excluding first {args.skip_frames} frame(s))\")\n</code></pre> <p>Recommendations: - Use <code>--backend cpp</code> for most applications - Use <code>--backend cupy</code> for systems &gt;100k atoms with NVIDIA GPU - Use <code>--backend python</code> only for testing or debugging</p>"},{"location":"cli-tools/#frame-stepping","title":"Frame Stepping","text":"<p>For long trajectories, use <code>--step</code> to sample every Nth frame:</p> <pre><code># Analyze every 10th frame (saves 90% computation time)\npywc-wc-area ... --step 10\n</code></pre> <p>This is often sufficient for converged statistics while dramatically reducing runtime.</p>"},{"location":"cli-tools/#grid-size-vs-performance","title":"Grid Size vs Performance","text":"<p>The <code>--grid-size</code> parameter affects thickness calculation:</p> Grid Size Spatial Resolution Performance Impact 10 ~8 \u00c5 bins Fast 20 ~4 \u00c5 bins Standard (recommended) 50 ~1.6 \u00c5 bins Slower, high detail"},{"location":"cli-tools/#the-center-option","title":"The <code>--center</code> Option","text":"<p>Important for Membranes</p> <p>Always use <code>--center</code> for membrane systems to avoid artifacts from periodic boundaries.</p> <p>The <code>--center</code> flag centers the analysis group in the unit cell before computing the density field. This prevents the membrane from being split across periodic boundaries, which would create artificial discontinuities in the surface.</p> <p>Without <code>--center</code>: <pre><code>Membrane wraps around box edge \u2192 Density field split \u2192 Incorrect surface\n</code></pre></p> <p>With <code>--center</code>: <pre><code>Membrane centered in box \u2192 Continuous density field \u2192 Correct surface\n</code></pre></p>"},{"location":"cli-tools/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-tools/#empty-surface-no-triangles","title":"Empty surface / No triangles","text":"<p>Problem: <code>area_angstrom2</code> is 0.0 or NaN</p> <p>Solutions: - Check that your selection contains atoms: <code>--selection \"resname DPPC\" | wc -l</code> - Adjust <code>--density-level</code> (try 0.5 or 1.5) - Verify trajectory is not corrupted - Check that <code>--alpha</code> and <code>--mesh</code> are reasonable</p>"},{"location":"cli-tools/#memory-errors-with-gpu-backend","title":"Memory errors with GPU backend","text":"<p>Problem: <code>cupy.cuda.memory.OutOfMemoryError</code></p> <p>Solutions: - Use smaller <code>--mesh</code> value (e.g., 3.0 instead of 2.0) - Use <code>--backend cpp</code> instead - Reduce selection to fewer atoms</p>"},{"location":"cli-tools/#surface-area-much-larger-than-box-area","title":"Surface area much larger than box area","text":"<p>Problem: <code>area_angstrom2 &gt;&gt; plane_area</code></p> <p>Solutions: - Use <code>--center</code> flag - Check that selection doesn't include bulk solvent - Verify <code>--density-level</code> is appropriate (try 1.0)</p>"},{"location":"cli-tools/#pywc-bending-rigidity","title":"pywc-bending-rigidity","text":"<p>Estimate membrane bending modulus from surface fluctuations.</p>"},{"location":"cli-tools/#basic-usage","title":"Basic Usage","text":"<pre><code>pywc-bending-rigidity \\\n    -s membrane.tpr \\\n    -x trajectory.xtc \\\n    --selection-file lipids.txt \\\n    --alpha 3.0 \\\n    --mesh 2.5\n</code></pre> <p>Coming Soon</p> <p>Detailed documentation for this tool is under development. See <code>pywc-bending-rigidity --help</code> for current options.</p>"},{"location":"cli-tools/#pywc-compare-wc-backends","title":"pywc-compare-wc-backends","text":"<p>Benchmark computational backends for your system.</p>"},{"location":"cli-tools/#basic-usage_1","title":"Basic Usage","text":"<pre><code>pywc-compare-wc-backends --help\n</code></pre> <p>Coming Soon</p> <p>Detailed documentation for this tool is under development. See <code>pywc-compare-wc-backends --help</code> for current options.</p>"},{"location":"cli-tools/#integration-with-analysis-pipelines","title":"Integration with Analysis Pipelines","text":""},{"location":"cli-tools/#bash-script-example","title":"Bash Script Example","text":"<pre><code>#!/bin/bash\n# Batch process multiple membrane simulations\n\nfor system in DPPC DOPC POPC; do\n    echo \"Processing ${system}...\"\n\n    pywc-wc-area \\\n        -s ${system}/system.tpr \\\n        -x ${system}/production.xtc \\\n        --selection-file ${system}/selection.txt \\\n        --alpha 3.0 \\\n        --mesh 2.5 \\\n        --backend cpp \\\n        --center \\\n        -b 50000 -e 100000 \\\n        -o ${system}_area.csv \\\n        --thickness-output ${system}_thickness.csv\ndone\n</code></pre>"},{"location":"cli-tools/#python-wrapper-example","title":"Python Wrapper Example","text":"<pre><code>import subprocess\nimport pandas as pd\n\nsystems = ['DPPC', 'DOPC', 'POPC']\nresults = {}\n\nfor system in systems:\n    # Run analysis\n    subprocess.run([\n        'pywc-wc-area',\n        '-s', f'{system}/system.tpr',\n        '-x', f'{system}/production.xtc',\n        '--selection-file', f'{system}/selection.txt',\n        '--alpha', '3.0',\n        '--mesh', '2.5',\n        '--backend', 'cpp',\n        '-o', f'{system}_area.csv'\n    ])\n\n    # Load results\n    df = pd.read_csv(f'{system}_area.csv')\n    results[system] = {\n        'mean_area': df['area_angstrom2'].mean(),\n        'std_area': df['area_angstrom2'].std()\n    }\n\n# Compare\nfor system, stats in results.items():\n    print(f\"{system}: {stats['mean_area']:.1f} \u00b1 {stats['std_area']:.1f} \u0172\")\n</code></pre>"},{"location":"cli-tools/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the Python API for custom analysis</li> <li>Explore Examples for common use cases</li> <li>Understand Backend Performance tradeoffs</li> </ul>"},{"location":"contributing/","title":"Contributing to pyWC","text":"<p>Thank you for considering contributing to pyWC! This page provides guidelines for contributing to the project.</p> <p>For the complete contribution guide, please see CONTRIBUTING.md in the repository.</p>"},{"location":"contributing/#quick-links","title":"Quick Links","text":"<ul> <li>Report Bugs: GitHub Issues</li> <li>Suggest Features: GitHub Issues</li> <li>Repository: github.com/octupole/pyWC</li> </ul>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code>git clone https://github.com/octupole/pyWC.git\ncd pyWC\n</code></pre>"},{"location":"contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install -e .[dev,gpu]\n</code></pre>"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write clear, documented code</li> <li>Follow existing code style (PEP 8)</li> <li>Add tests if applicable</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#4-submit-pull-request","title":"4. Submit Pull Request","text":"<pre><code>git checkout -b feature/your-feature\ngit add .\ngit commit -m \"Description of changes\"\ngit push origin feature/your-feature\n</code></pre> <p>Then open a pull request on GitHub.</p>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":"<p>We especially welcome contributions in:</p> <ul> <li>Performance improvements: GPU optimizations, SIMD vectorization</li> <li>Documentation: Examples, tutorials, API docs</li> <li>Testing: Expanded test coverage, benchmarks</li> <li>Features: New analysis metrics, output formats</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Accept constructive criticism</li> <li>Focus on what's best for the community</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue for questions</li> <li>Email: massimo@octupole.org</li> <li>See full guide: CONTRIBUTING.md</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page provides real-world examples of using pyWC for different molecular systems.</p>"},{"location":"examples/#watervapor-interface","title":"Water/Vapor Interface","text":"<p>Analyze a liquid-vapor interface:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport numpy as np\n\n# Load water system\nu = mda.Universe(\"water.gro\", \"water.xtc\")\nwater = u.select_atoms(\"resname SOL\")\n\n# Create WillardChandler object\nwc = WillardChandler(\n    u,\n    group=water,\n    alpha=2.4,        # Standard for water\n    mesh=2.0,\n    centered=True,\n    surface_backend='cpp'\n)\n\n# Analyze trajectory\nareas = []\nfor ts in u.trajectory:\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n\n# Statistics\nprint(f\"Mean area: {np.mean(areas):.2f} \u00b1 {np.std(areas):.2f} \u0172\")\n\n# Export final frame\nwc.writevtk.surface(\"water_surface.vtk\")\n</code></pre>"},{"location":"examples/#lipid-bilayer","title":"Lipid Bilayer","text":"<p>Characterize membrane surfaces:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load DPPC bilayer\nu = mda.Universe(\"dppc.gro\", \"dppc.xtc\")\n\n# Select phosphate groups (headgroups)\nupper_leaflet = u.select_atoms(\"resname DPPC and name P and prop z &gt; 0\")\nlower_leaflet = u.select_atoms(\"resname DPPC and name P and prop z &lt; 0\")\n\n# Analyze upper leaflet\nwc_upper = WillardChandler(\n    u,\n    group=upper_leaflet,\n    alpha=3.0,        # Larger for lipids\n    mesh=2.0,\n    centered=False    # Leaflets already positioned\n)\n\nwc_upper.assign_surface()\nprint(f\"Upper leaflet area: {wc_upper.surface_area:.2f} \u0172\")\n\n# Analyze lower leaflet\nwc_lower = WillardChandler(\n    u,\n    group=lower_leaflet,\n    alpha=3.0,\n    mesh=2.0\n)\n\nwc_lower.assign_surface()\nprint(f\"Lower leaflet area: {wc_lower.surface_area:.2f} \u0172\")\n\n# Export both surfaces\nwc_upper.writevtk.surface(\"upper_leaflet.vtk\")\nwc_lower.writevtk.surface(\"lower_leaflet.vtk\")\n</code></pre>"},{"location":"examples/#micelle-analysis","title":"Micelle Analysis","text":"<p>Analyze surfactant micelle:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport matplotlib.pyplot as plt\n\n# Load DPC micelle\nu = mda.Universe(\"micelle.pdb\")\nheadgroups = u.select_atoms(\"resname DPC and name N\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=headgroups,\n    alpha=3.0,\n    mesh=2.0,\n    centered=True\n)\n\n# Get surface\nvertices, faces, normals = wc.triangulated_surface\n\n# Calculate radius distribution\ncenter = vertices.mean(axis=0)\nradii = np.linalg.norm(vertices - center, axis=1)\n\nprint(f\"Mean radius: {radii.mean():.2f} \u00b1 {radii.std():.2f} \u00c5\")\n\n# Plot radius distribution\nplt.hist(radii, bins=30)\nplt.xlabel(\"Radius (\u00c5)\")\nplt.ylabel(\"Count\")\nplt.savefig(\"micelle_radius_dist.png\")\n\n# Export\nwc.writeobj(\"micelle.obj\")\n</code></pre>"},{"location":"examples/#protein-surface","title":"Protein Surface","text":"<p>Compute protein surface:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load protein system\nu = mda.Universe(\"protein.pdb\", \"protein.xtc\")\nprotein = u.select_atoms(\"protein\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=protein,\n    alpha=3.5,        # Larger for proteins\n    mesh=2.5,\n    centered=True,\n    surface_backend='cpp'\n)\n\n# Process trajectory\nfor ts in u.trajectory[::10]:  # Every 10th frame\n    wc.assign_surface()\n    area = wc.surface_area\n    print(f\"Frame {ts.frame:4d}: Area = {area:.2f} \u0172\")\n\n    # Save snapshots\n    if ts.frame % 100 == 0:\n        wc.writevtk.surface(f\"protein_{ts.frame:04d}.vtk\")\n</code></pre>"},{"location":"examples/#gpu-backend-for-large-systems","title":"GPU Backend for Large Systems","text":"<p>Use GPU acceleration for large systems:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport time\n\n# Load large system\nu = mda.Universe(\"large_system.gro\", \"large_system.xtc\")\natoms = u.select_atoms(\"all\")\n\nprint(f\"System size: {len(atoms)} atoms\")\n\n# Compare backends\nfor backend in ['cpp', 'cupy']:\n    try:\n        wc = WillardChandler(\n            u,\n            group=atoms,\n            alpha=2.4,\n            mesh=2.0,\n            surface_backend=backend,\n            enable_timing=True\n        )\n\n        start = time.time()\n        wc.assign_surface()\n        elapsed = time.time() - start\n\n        print(f\"{backend:10s}: {elapsed:.4f} s, Area = {wc.surface_area:.2f} \u0172\")\n\n    except Exception as e:\n        print(f\"{backend:10s}: Not available ({e})\")\n</code></pre>"},{"location":"examples/#trajectory-analysis-with-plotting","title":"Trajectory Analysis with Plotting","text":"<p>Analyze surface evolution over time:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load trajectory\nu = mda.Universe(\"system.gro\", \"trajectory.xtc\")\ngroup = u.select_atoms(\"resname DPPC and name P\")\n\n# Create WillardChandler\nwc = WillardChandler(\n    u, group=group,\n    alpha=3.0, mesh=2.0,\n    centered=True\n)\n\n# Collect data\ntimes = []\nareas = []\nn_vertices = []\n\nfor ts in u.trajectory[::5]:  # Every 5th frame\n    wc.assign_surface()\n\n    times.append(ts.time)\n    areas.append(wc.surface_area)\n\n    vertices, _, _ = wc.triangulated_surface\n    n_vertices.append(len(vertices))\n\n# Convert to arrays\ntimes = np.array(times)\nareas = np.array(areas)\nn_vertices = np.array(n_vertices)\n\n# Plot\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n\n# Surface area\nax1.plot(times, areas, 'b-', linewidth=0.5, alpha=0.7)\nax1.axhline(areas.mean(), color='r', linestyle='--',\n            label=f'Mean: {areas.mean():.1f} \u0172')\nax1.fill_between(times,\n                 areas.mean()-areas.std(),\n                 areas.mean()+areas.std(),\n                 alpha=0.2, color='r')\nax1.set_ylabel('Surface Area (\u0172)')\nax1.legend()\nax1.grid(alpha=0.3)\n\n# Number of vertices\nax2.plot(times, n_vertices, 'g-', linewidth=0.5, alpha=0.7)\nax2.set_xlabel('Time (ps)')\nax2.set_ylabel('Number of Vertices')\nax2.grid(alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('surface_analysis.png', dpi=300)\n\n# Statistics\nprint(f\"Area: {areas.mean():.2f} \u00b1 {areas.std():.2f} \u0172\")\nprint(f\"Vertices: {n_vertices.mean():.0f} \u00b1 {n_vertices.std():.0f}\")\n</code></pre>"},{"location":"examples/#computing-bending-rigidity","title":"Computing Bending Rigidity","text":"<p>Use the built-in script:</p> <pre><code>pywc-bending-rigidity \\\n    --topology system.gro \\\n    --trajectory traj.xtc \\\n    --selection \"resname DPPC and name P\" \\\n    --alpha 3.0 \\\n    --mesh 2.0 \\\n    --output bending_rigidity.csv\n</code></pre> <p>Or from Python:</p> <pre><code>from scripts.compute_bending_rigidity import analyze_bending_rigidity\n\nresults = analyze_bending_rigidity(\n    topology=\"system.gro\",\n    trajectory=\"traj.xtc\",\n    selection=\"resname DPPC and name P\",\n    alpha=3.0,\n    mesh=2.0\n)\n\nprint(f\"Bending modulus: {results['kappa']:.3f} kT\")\n</code></pre>"},{"location":"examples/#thickness-mapping","title":"Thickness Mapping","text":"<p>Compute membrane thickness:</p> <pre><code>from scripts.compute_willard_chandler_area import compute_thickness_map\n\nthickness_map = compute_thickness_map(\n    topology=\"bilayer.gro\",\n    trajectory=\"bilayer.xtc\",\n    selection_upper=\"resname DPPC and name P and prop z &gt; 0\",\n    selection_lower=\"resname DPPC and name P and prop z &lt; 0\",\n    grid_spacing=2.0\n)\n\n# Visualize\nimport matplotlib.pyplot as plt\n\nplt.imshow(thickness_map, cmap='viridis', origin='lower')\nplt.colorbar(label='Thickness (\u00c5)')\nplt.xlabel('X (grid points)')\nplt.ylabel('Y (grid points)')\nplt.title('Membrane Thickness Map')\nplt.savefig('thickness_map.png', dpi=300)\n</code></pre>"},{"location":"examples/#export-to-multiple-formats","title":"Export to Multiple Formats","text":"<pre><code>from pywc import WillardChandler\n\n# ... create and compute surface ...\n\n# VTK for ParaView\nwc.writevtk.surface(\"surface.vtk\")\nwc.writevtk.density(\"density.vtk\")\nwc.writevtk.atoms(\"atoms.vtk\")\n\n# Wavefront OBJ for Blender\nwc.writeobj(\"surface.obj\")\n\n# Gaussian Cube for quantum chemistry\nwc.writecube(\"density.cube\")\n\n# PDB for molecular viewers\nwc.writepdb.surface(\"surface.pdb\")\n</code></pre>"},{"location":"examples/#custom-analysis","title":"Custom Analysis","text":"<p>Extract surface properties for custom analysis:</p> <pre><code>from pywc import WillardChandler\nimport numpy as np\n\n# Compute surface\nwc = WillardChandler(u, group=atoms, alpha=2.4, mesh=2.0)\nvertices, faces, normals = wc.triangulated_surface\n\n# Calculate local curvature\ndef compute_curvature(vertices, faces):\n    # Custom curvature calculation\n    # (simplified example)\n    curvatures = []\n    for i, vertex in enumerate(vertices):\n        # Find neighboring faces\n        neighbor_faces = faces[np.any(faces == i, axis=1)]\n        # Compute local curvature\n        # ... your calculation ...\n        curvatures.append(curvature_value)\n    return np.array(curvatures)\n\ncurvatures = compute_curvature(vertices, faces)\n\n# Visualize\nimport matplotlib.pyplot as plt\nplt.hist(curvatures, bins=50)\nplt.xlabel('Curvature (1/\u00c5)')\nplt.ylabel('Count')\nplt.savefig('curvature_distribution.png')\n</code></pre>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Quick Start - Basic usage</li> <li>Backends - Backend selection guide</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This guide covers installing pyWC on different platforms and configurations.</p>"},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: \u2265 3.10</li> <li>C++ Compiler: Supporting C++17 (GCC 7+, Clang 5+, MSVC 2017+)</li> <li>OpenMP: For CPU parallelization</li> </ul>"},{"location":"installation/#platform-support","title":"Platform Support","text":"<ul> <li>Linux (tested on Ubuntu 20.04+, Fedora, Arch)</li> <li>macOS (tested on 11.0+, both Intel and Apple Silicon)</li> <li>Windows (tested on Windows 10/11 with Visual Studio 2017+)</li> </ul>"},{"location":"installation/#basic-installation-cpu-only","title":"Basic Installation (CPU Only)","text":""},{"location":"installation/#from-source","title":"From Source","text":"<p>Clone the repository and install:</p> <pre><code>git clone https://github.com/octupole/pyWC.git\ncd pyWC\npip install .\n</code></pre> <p>This will: - Build C++ extensions with OpenMP support - Install all required dependencies - Make command-line tools available</p>"},{"location":"installation/#dependencies-installed","title":"Dependencies Installed","text":"<p>The basic installation includes:</p> <ul> <li><code>numpy</code> \u2265 2.1.3 - Numerical arrays</li> <li><code>scipy</code> \u2265 1.11.3 - Scientific computing</li> <li><code>scikit-image</code> \u2265 0.24.0 - Marching cubes algorithm</li> <li><code>MDAnalysis</code> \u2265 2.8.0 - Trajectory I/O</li> <li><code>packaging</code> \u2265 23.0 - Version handling</li> </ul>"},{"location":"installation/#build-dependencies","title":"Build Dependencies","text":"<p>The following are needed at build time:</p> <ul> <li><code>pybind11</code> \u2265 2.11 - C++/Python bindings</li> <li><code>Cython</code> - For DBSCAN extension</li> <li><code>setuptools</code> \u2265 61.0</li> <li><code>wheel</code></li> </ul> <p>These are automatically installed during the build process.</p>"},{"location":"installation/#gpu-acceleration-optional","title":"GPU Acceleration (Optional)","text":"<p>For GPU support on NVIDIA GPUs:</p>"},{"location":"installation/#step-1-install-cuda-toolkit","title":"Step 1: Install CUDA Toolkit","text":"<p>Download and install from NVIDIA CUDA Downloads.</p> <p>Verify installation: <pre><code>nvcc --version\nnvidia-smi\n</code></pre></p>"},{"location":"installation/#step-2-install-cupy","title":"Step 2: Install CuPy","text":"<p>Choose the appropriate CuPy package for your CUDA version:</p> CUDA 12.xCUDA 11.xAuto-detect <pre><code>pip install cupy-cuda12x\n</code></pre> <pre><code>pip install cupy-cuda11x\n</code></pre> <pre><code>pip install cupy\n</code></pre>"},{"location":"installation/#step-3-install-pywc-with-gpu-support","title":"Step 3: Install pyWC with GPU Support","text":"<pre><code>pip install .[gpu]\n</code></pre> <p>Or if installing from source with CUDA detected: <pre><code>pip install .  # Automatically includes CuPy if CUDA is detected\n</code></pre></p>"},{"location":"installation/#skip-gpu-installation","title":"Skip GPU Installation","text":"<p>If you have CUDA but don't want GPU support:</p> <pre><code>export PYWC_SKIP_CUPY=1\npip install .\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> <pre><code>git clone https://github.com/octupole/pyWC.git\ncd pyWC\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install in editable mode with dev dependencies\npip install -e .[dev,gpu]\n</code></pre> <p>This installs additional tools: - <code>nose</code> - Testing framework - <code>coverage</code> - Code coverage analysis</p>"},{"location":"installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"installation/#linux","title":"Linux","text":""},{"location":"installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install build dependencies\nsudo apt-get update\nsudo apt-get install build-essential python3-dev libomp-dev\n\n# Install pyWC\npip install .\n</code></pre>"},{"location":"installation/#fedorarhel","title":"Fedora/RHEL","text":"<pre><code># Install build dependencies\nsudo dnf install gcc-c++ python3-devel libomp-devel\n\n# Install pyWC\npip install .\n</code></pre>"},{"location":"installation/#arch-linux","title":"Arch Linux","text":"<pre><code># Install build dependencies\nsudo pacman -S base-devel python openmp\n\n# Install pyWC\npip install .\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":""},{"location":"installation/#install-homebrew-if-not-installed","title":"Install Homebrew (if not installed)","text":"<pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre>"},{"location":"installation/#install-openmp","title":"Install OpenMP","text":"<pre><code>brew install libomp\n</code></pre>"},{"location":"installation/#install-pywc","title":"Install pyWC","text":"<pre><code>pip install .\n</code></pre> <p>Apple Silicon (M1/M2/M3)</p> <p>pyWC works on Apple Silicon Macs. Use Python from Homebrew or miniforge for best compatibility: <pre><code>brew install python@3.11\n# or\nbrew install miniforge\n</code></pre></p>"},{"location":"installation/#windows","title":"Windows","text":""},{"location":"installation/#install-visual-studio","title":"Install Visual Studio","text":"<ol> <li>Download Visual Studio 2022 Community</li> <li>During installation, select:</li> <li>\"Desktop development with C++\"</li> <li>Ensure \"MSVC v143\" and \"Windows 10 SDK\" are checked</li> </ol>"},{"location":"installation/#install-python","title":"Install Python","text":"<p>Download from python.org or use Anaconda.</p>"},{"location":"installation/#install-pywc_1","title":"Install pyWC","text":"<pre><code>pip install .\n</code></pre> <p>Windows Subsystem for Linux (WSL)</p> <p>For best experience on Windows, consider using WSL2 with Ubuntu: <pre><code>wsl --install -d Ubuntu-22.04\n</code></pre> Then follow Linux installation instructions.</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"installation/#test-basic-import","title":"Test Basic Import","text":"<pre><code>python -c \"from pywc import WillardChandler; print('pyWC installed successfully!')\"\n</code></pre>"},{"location":"installation/#test-c-extensions","title":"Test C++ Extensions","text":"<pre><code>from pywc import WillardChandler\nfrom pywc._wc_kde import evaluate_pbc_fast_auto\nprint(\"C++ extensions loaded successfully!\")\n</code></pre>"},{"location":"installation/#test-gpu-support-if-installed","title":"Test GPU Support (if installed)","text":"<pre><code>from pywc.center_gpu import center_gpu\nprint(\"GPU support available!\")\n</code></pre>"},{"location":"installation/#run-command-line-tools","title":"Run Command-Line Tools","text":"<pre><code>pywc-compare-wc-backends --help\npywc-wc-area --help\npywc-bending-rigidity --help\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#openmp-not-found","title":"OpenMP Not Found","text":"LinuxmacOSWindows <pre><code>sudo apt-get install libomp-dev  # Ubuntu/Debian\nsudo dnf install libomp-devel    # Fedora/RHEL\n</code></pre> <pre><code>brew install libomp\n</code></pre> <p>Visual Studio includes OpenMP support. Ensure you selected \"Desktop development with C++\".</p>"},{"location":"installation/#cuda-not-detected","title":"CUDA Not Detected","text":"<pre><code># Set CUDA_HOME environment variable\nexport CUDA_HOME=/usr/local/cuda         # Linux\nexport CUDA_HOME=/opt/cuda              # Some Linux systems\nset CUDA_HOME=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.0  # Windows\n</code></pre>"},{"location":"installation/#compilation-errors","title":"Compilation Errors","text":"<p>If you encounter compilation errors:</p> <ol> <li> <p>Update build tools: <pre><code>pip install --upgrade pip setuptools wheel\n</code></pre></p> </li> <li> <p>Install specific pybind11 version: <pre><code>pip install pybind11==2.11.1\n</code></pre></p> </li> <li> <p>Clean build: <pre><code>rm -rf build/ dist/ *.egg-info\npip install .\n</code></pre></p> </li> </ol>"},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>If you get import errors after installation:</p> <pre><code># Ensure you're not in the source directory\ncd ~\npython -c \"import pywc; print(pywc.__version__)\"\n</code></pre>"},{"location":"installation/#performance-issues","title":"Performance Issues","text":"<p>If C++ extensions are not being used:</p> <pre><code>import pywc\nprint(pywc._center_impl.HAS_CENTER_FAST)  # Should be True\nprint(pywc._center_impl.HAS_CENTER_GPU)   # True if CuPy installed\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn basic usage</li> <li>API Reference - Detailed API documentation</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with pyWC in just a few minutes.</p>"},{"location":"quickstart/#your-first-surface-calculation","title":"Your First Surface Calculation","text":""},{"location":"quickstart/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>pyWC works with any trajectory format supported by MDAnalysis (GROMACS, CHARMM, LAMMPS, AMBER, etc.).</p> <p>For this tutorial, we'll use the test trajectory included with pyWC:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nfrom pywc.datafiles import NPT_RUN_TPR, TRAJ_TEST_XTC, SELECTION_TXT\n\n# Load the test trajectory\nu = mda.Universe(NPT_RUN_TPR, TRAJ_TEST_XTC)\n</code></pre>"},{"location":"quickstart/#step-2-select-atoms","title":"Step 2: Select Atoms","text":"<p>Select the group of atoms you want to analyze. For this example, we'll load a selection from file:</p> <pre><code># Load selection from file\nwith open(SELECTION_TXT) as f:\n    selection_text = f.read().strip()\n\n# Apply selection\ngroup = u.select_atoms(selection_text)\n\nprint(f\"Selected {len(group)} atoms\")\n</code></pre>"},{"location":"quickstart/#step-3-create-willardchandler-object","title":"Step 3: Create WillardChandler Object","text":"<pre><code>wc = WillardChandler(\n    u,\n    group=group,\n    alpha=3.0,           # Gaussian width in \u00c5ngstr\u00f6ms\n    mesh=2.5,            # Grid spacing in \u00c5ngstr\u00f6ms\n    centered=True,       # Center the system\n    surface_backend='cpp' # Use C++ backend\n)\n</code></pre>"},{"location":"quickstart/#step-4-compute-and-analyze-surface","title":"Step 4: Compute and Analyze Surface","text":"<pre><code># Get triangulated surface\nvertices, faces, normals = wc.triangulated_surface\n\n# Get surface area\nprint(f\"Surface area: {wc.surface_area:.2f} \u0172\")\n\n# Export to VTK for visualization\nwc.writevtk.surface(\"water_surface.vtk\")\n</code></pre> <p>That's it! You've computed your first Willard-Chandler surface.</p>"},{"location":"quickstart/#understanding-the-parameters","title":"Understanding the Parameters","text":""},{"location":"quickstart/#alpha-gaussian-width","title":"<code>alpha</code> - Gaussian Width","text":"<p>Controls the smoothness of the density field:</p> <ul> <li>Smaller values (1.5-2.5 \u00c5): Sharper, more detailed surfaces</li> <li>Larger values (3.0-4.0 \u00c5): Smoother surfaces, less noise</li> </ul> <p>Rule of thumb: Start with 2-3 \u00c5 for water, 3-4 \u00c5 for lipids.</p> <pre><code># Sharp surface\nwc_sharp = WillardChandler(u, group=water, alpha=2.0, mesh=2.0)\n\n# Smooth surface\nwc_smooth = WillardChandler(u, group=water, alpha=4.0, mesh=2.0)\n</code></pre>"},{"location":"quickstart/#mesh-grid-spacing","title":"<code>mesh</code> - Grid Spacing","text":"<p>Controls the resolution of the density grid:</p> <ul> <li>Smaller values (1.0-1.5 \u00c5): Higher resolution, slower computation</li> <li>Larger values (2.0-3.0 \u00c5): Lower resolution, faster computation</li> </ul> <p>Rule of thumb: Use 2.0 \u00c5 for most applications.</p> <pre><code># High resolution (slower)\nwc_highres = WillardChandler(u, group=water, alpha=2.4, mesh=1.0)\n\n# Standard resolution\nwc_standard = WillardChandler(u, group=water, alpha=2.4, mesh=2.0)\n</code></pre>"},{"location":"quickstart/#centered-system-centering","title":"<code>centered</code> - System Centering","text":"<p>Whether to center the selected group in the simulation box:</p> <ul> <li><code>True</code>: Recommended for most cases, avoids periodic boundary artifacts</li> <li><code>False</code>: Use if system is already properly positioned</li> </ul> <pre><code>wc = WillardChandler(u, group=water, alpha=2.4, mesh=2.0, centered=True)\n</code></pre>"},{"location":"quickstart/#surface_backend-computational-backend","title":"<code>surface_backend</code> - Computational Backend","text":"<p>Choose the backend based on your system size and available hardware:</p> Backend When to Use Performance <code>'cpp'</code> Default, best for most systems ~35x faster than Python <code>'cupy'</code> Large systems (&gt;10k atoms) with NVIDIA GPU ~5-6x faster than C++ <code>'python'</code> Testing, debugging, or when C++ unavailable Baseline <pre><code># CPU backend (default, recommended)\nwc_cpu = WillardChandler(u, group=water, alpha=2.4, mesh=2.0,\n                         surface_backend='cpp')\n\n# GPU backend (requires CuPy)\nwc_gpu = WillardChandler(u, group=water, alpha=2.4, mesh=2.0,\n                         surface_backend='cupy')\n</code></pre>"},{"location":"quickstart/#common-use-cases","title":"Common Use Cases","text":""},{"location":"quickstart/#lipid-bilayer-surfaces","title":"Lipid Bilayer Surfaces","text":"<pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load lipid bilayer simulation\nu = mda.Universe(\"bilayer.gro\", \"bilayer.xtc\")\n\n# Select phosphate groups (headgroups)\nheadgroups = u.select_atoms(\"name P or name PO4\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=headgroups,\n    alpha=3.0,        # Larger alpha for lipids\n    mesh=2.0,\n    centered=True\n)\n\n# Analyze\nprint(f\"Membrane surface area: {wc.surface_area:.2f} \u0172\")\nwc.writevtk.surface(\"membrane.vtk\")\n</code></pre>"},{"location":"quickstart/#protein-surface","title":"Protein Surface","text":"<pre><code># Select protein\nprotein = u.select_atoms(\"protein\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=protein,\n    alpha=3.5,        # Larger for proteins\n    mesh=2.5,\n    centered=True\n)\n\nprint(f\"Protein surface area: {wc.surface_area:.2f} \u0172\")\n</code></pre>"},{"location":"quickstart/#micelle-analysis","title":"Micelle Analysis","text":"<pre><code># Select surfactant headgroups\nsurfactant = u.select_atoms(\"resname DPC and name N\")\n\nwc = WillardChandler(\n    u,\n    group=surfactant,\n    alpha=3.0,\n    mesh=2.0,\n    centered=True\n)\n\n# Export for visualization\nwc.writeobj(\"micelle.obj\")\n</code></pre>"},{"location":"quickstart/#trajectory-analysis","title":"Trajectory Analysis","text":"<p>Process multiple frames to analyze surface evolution:</p> <pre><code>import numpy as np\n\n# Track surface area over time\nareas = []\ntimes = []\n\nfor ts in u.trajectory[::10]:  # Every 10th frame\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n    times.append(ts.time)\n    print(f\"Frame {ts.frame}: Area = {wc.surface_area:.2f} \u0172\")\n\n# Calculate statistics\nmean_area = np.mean(areas)\nstd_area = np.std(areas)\nprint(f\"\\nMean area: {mean_area:.2f} \u00b1 {std_area:.2f} \u0172\")\n\n# Plot\nimport matplotlib.pyplot as plt\nplt.plot(times, areas)\nplt.xlabel(\"Time (ps)\")\nplt.ylabel(\"Surface Area (\u0172)\")\nplt.savefig(\"area_vs_time.png\")\n</code></pre>"},{"location":"quickstart/#exporting-results","title":"Exporting Results","text":""},{"location":"quickstart/#vtk-format-paraview-vmd","title":"VTK Format (ParaView, VMD)","text":"<pre><code># Export surface\nwc.writevtk.surface(\"surface.vtk\")\n\n# Export density field\nwc.writevtk.density(\"density.vtk\")\n\n# Export atoms\nwc.writevtk.atoms(\"atoms.vtk\")\n</code></pre> <p>Visualize in ParaView: 1. Open <code>surface.vtk</code> 2. Apply \"Extract Surface\" filter 3. Color by normals or other properties</p>"},{"location":"quickstart/#wavefront-obj-blender-3d-software","title":"Wavefront OBJ (Blender, 3D Software)","text":"<pre><code>wc.writeobj(\"surface.obj\")\n</code></pre> <p>Open in Blender: 1. File \u2192 Import \u2192 Wavefront (.obj) 2. Select <code>surface.obj</code></p>"},{"location":"quickstart/#gaussian-cube-quantum-chemistry","title":"Gaussian Cube (Quantum Chemistry)","text":"<pre><code>wc.writecube(\"density.cube\")\n</code></pre> <p>Compatible with Gaussian, ORCA, VMD, etc.</p>"},{"location":"quickstart/#pdb-molecular-viewers","title":"PDB (Molecular Viewers)","text":"<pre><code>wc.writepdb.surface(\"surface.pdb\")\n</code></pre>"},{"location":"quickstart/#performance-tips","title":"Performance Tips","text":""},{"location":"quickstart/#enable-timing","title":"Enable Timing","text":"<p>Track performance of different components:</p> <pre><code>wc = WillardChandler(\n    u, group=water,\n    alpha=2.4, mesh=2.0,\n    enable_timing=True\n)\n\n# After computation\nprint(f\"Total time: {wc.get_timing():.4f} s\")\n</code></pre>"},{"location":"quickstart/#choose-appropriate-backend","title":"Choose Appropriate Backend","text":"<pre><code># For small systems (&lt;1000 atoms)\nwc = WillardChandler(u, group=small_group, surface_backend='cpp')\n\n# For large systems (&gt;10000 atoms) with GPU\nwc = WillardChandler(u, group=large_group, surface_backend='cupy')\n</code></pre>"},{"location":"quickstart/#optimize-parameters","title":"Optimize Parameters","text":"<p>Balance accuracy and performance:</p> <pre><code># Fast computation (lower accuracy)\nwc_fast = WillardChandler(u, group=water, alpha=3.0, mesh=3.0)\n\n# High accuracy (slower)\nwc_accurate = WillardChandler(u, group=water, alpha=2.0, mesh=1.0)\n</code></pre>"},{"location":"quickstart/#skip-warmup-frames","title":"Skip Warmup Frames","text":"<p>For trajectory analysis, skip initial equilibration:</p> <pre><code>for ts in u.trajectory[100:]:  # Skip first 100 frames\n    wc.assign_surface()\n    # Analysis...\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - More detailed examples</li> <li>Backends - Deep dive into computational backends</li> <li>Citation - How to cite pyWC in publications</li> </ul>"},{"location":"api/backends/","title":"Computational Backends","text":"<p>pyWC provides three computational backends for density evaluation, each optimized for different use cases.</p>"},{"location":"api/backends/#backend-overview","title":"Backend Overview","text":"Backend Implementation Performance Use Case C++ pybind11 + OpenMP ~35x faster Default, production use GPU CuPy/CUDA ~5-6x faster than C++ Large systems (&gt;10k atoms) Python NumPy/SciPy Baseline Testing, debugging"},{"location":"api/backends/#c-backend","title":"C++ Backend","text":"<p>The default and recommended backend for most applications.</p>"},{"location":"api/backends/#features","title":"Features","text":"<ul> <li>OpenMP parallelization: Uses all available CPU cores</li> <li>Cell-list neighbor search: Efficient neighbor finding with PBC</li> <li>Atomic operations: Thread-safe parallel accumulation</li> <li>~35x speedup over pure Python</li> </ul>"},{"location":"api/backends/#usage","title":"Usage","text":"<pre><code>from pywc import WillardChandler\n\nwc = WillardChandler(\n    u, group=atoms,\n    alpha=2.4, mesh=2.0,\n    surface_backend='cpp'  # Default\n)\n</code></pre>"},{"location":"api/backends/#requirements","title":"Requirements","text":"<ul> <li>C++17 compatible compiler</li> <li>OpenMP support</li> <li>pybind11 \u2265 2.11</li> </ul>"},{"location":"api/backends/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Memory: O(N + grid_size)</li> <li>Time complexity: O(N \u00d7 neighbors)</li> <li>Scales linearly with number of atoms</li> <li>Best for: 100 - 100,000 atoms</li> </ul>"},{"location":"api/backends/#implementation-details","title":"Implementation Details","text":"<p>The C++ backend uses two main algorithms:</p> <p>1. <code>evaluate_pbc_fast_auto()</code> (Recommended) - Self-contained cell-list generation - Automatic neighbor search - ~35x faster than Python - No preprocessing required</p> <p>2. <code>evaluate_pbc_fast()</code> (Legacy) - Accepts pre-computed neighbor lists - Backward compatible with pytim - Slightly slower due to Python overhead</p> <pre><code># Automatic (recommended)\nfrom pywc._wc_kde import evaluate_pbc_fast_auto\n\nresult = evaluate_pbc_fast_auto(\n    positions,    # Atomic positions\n    grid,         # Grid points\n    box,          # Box dimensions\n    alpha,        # Gaussian width\n    weights       # Atomic weights\n)\n</code></pre>"},{"location":"api/backends/#compiler-optimization-flags","title":"Compiler Optimization Flags","text":"<p>The build system uses: - <code>-O3</code>: Aggressive optimization - <code>-std=c++17</code>: Modern C++ features - <code>-fopenmp</code>: OpenMP parallelization</p> <p>On Windows (MSVC): - <code>/O2</code>: Optimization - <code>/std:c++17</code>: C++17 standard - <code>/openmp</code>: OpenMP support</p>"},{"location":"api/backends/#gpu-backend","title":"GPU Backend","text":"<p>For large systems with NVIDIA GPUs.</p>"},{"location":"api/backends/#features_1","title":"Features","text":"<ul> <li>CUDA kernels: Custom GPU kernels for Gaussian accumulation</li> <li>Cell-list on GPU: Neighbor search entirely on device</li> <li>Chunked processing: Manages GPU memory automatically</li> <li>~5-6x faster than C++ for large systems</li> </ul>"},{"location":"api/backends/#usage_1","title":"Usage","text":"<pre><code>wc = WillardChandler(\n    u, group=atoms,\n    alpha=2.4, mesh=2.0,\n    surface_backend='cupy'  # GPU backend\n)\n</code></pre>"},{"location":"api/backends/#requirements_1","title":"Requirements","text":"<ul> <li>NVIDIA GPU with CUDA support (Compute Capability \u2265 6.0)</li> <li>CUDA Toolkit 11.0+</li> <li>CuPy \u2265 12.0</li> </ul>"},{"location":"api/backends/#installation","title":"Installation","text":"<p>See Installation Guide for details.</p>"},{"location":"api/backends/#performance-characteristics_1","title":"Performance Characteristics","text":"<ul> <li>Memory: GPU RAM = O(N + grid_size)</li> <li>Best for: &gt;10,000 atoms</li> <li>Speedup: 5-6x over C++ (system dependent)</li> <li>Overhead: Initial data transfer to GPU</li> </ul>"},{"location":"api/backends/#when-to-use-gpu-backend","title":"When to Use GPU Backend","text":"<p>\u2705 Use GPU when: - System has &gt;10,000 atoms - Processing many frames - NVIDIA GPU available - High throughput needed</p> <p>\u274c Use C++ when: - System has &lt;10,000 atoms - Single frame calculation - No GPU available - CPU has many cores</p>"},{"location":"api/backends/#gpu-memory-management","title":"GPU Memory Management","text":"<p>The GPU backend automatically chunks large grids:</p> <pre><code># For very large systems, adjust chunk size\nimport os\nos.environ['PYWC_GPU_CHUNK_SIZE'] = '5000000'  # Grid points per chunk\n</code></pre>"},{"location":"api/backends/#troubleshooting-gpu","title":"Troubleshooting GPU","text":"<p>Check GPU availability: <pre><code>import cupy as cp\nprint(f\"GPU: {cp.cuda.Device().name}\")\nprint(f\"Memory: {cp.cuda.Device().mem_info[1] / 1e9:.1f} GB\")\n</code></pre></p> <p>Force CPU if GPU fails: <pre><code>try:\n    wc = WillardChandler(u, group=atoms, surface_backend='cupy')\nexcept Exception as e:\n    print(f\"GPU failed: {e}, falling back to CPU\")\n    wc = WillardChandler(u, group=atoms, surface_backend='cpp')\n</code></pre></p>"},{"location":"api/backends/#python-backend","title":"Python Backend","text":"<p>Pure NumPy/SciPy implementation for reference and testing.</p>"},{"location":"api/backends/#features_2","title":"Features","text":"<ul> <li>No compilation required: Works immediately</li> <li>Reference implementation: Validates other backends</li> <li>Cross-platform: Works everywhere Python runs</li> </ul>"},{"location":"api/backends/#usage_2","title":"Usage","text":"<pre><code>wc = WillardChandler(\n    u, group=atoms,\n    alpha=2.4, mesh=2.0,\n    surface_backend='python'\n)\n</code></pre>"},{"location":"api/backends/#when-to-use","title":"When to Use","text":"<ul> <li>Testing/debugging</li> <li>Platforms without C++ compiler</li> <li>Verifying results</li> <li>Understanding algorithm</li> </ul>"},{"location":"api/backends/#performance","title":"Performance","text":"<p>Significantly slower than C++ or GPU backends. Use only for small systems or testing.</p>"},{"location":"api/backends/#backend-selection-strategy","title":"Backend Selection Strategy","text":""},{"location":"api/backends/#automatic-selection","title":"Automatic Selection","text":"<p>pyWC doesn't auto-select backends. Choose explicitly based on your needs:</p> <pre><code>def choose_backend(n_atoms, has_gpu):\n    if has_gpu and n_atoms &gt; 10000:\n        return 'cupy'\n    else:\n        return 'cpp'\n\n# Example\nbackend = choose_backend(len(atoms), HAS_GPU)\nwc = WillardChandler(u, group=atoms, surface_backend=backend)\n</code></pre>"},{"location":"api/backends/#benchmark-your-system","title":"Benchmark Your System","text":"<p>Use the included benchmark tool:</p> <pre><code>pywc-compare-wc-backends\n</code></pre> <p>This will test all available backends on your system and report timings.</p>"},{"location":"api/backends/#from-python","title":"From Python","text":"<pre><code>from pywc import WillardChandler\nimport time\n\nbackends = ['cpp']\ntry:\n    import cupy\n    backends.append('cupy')\nexcept ImportError:\n    pass\n\nfor backend in backends:\n    wc = WillardChandler(u, group=atoms, surface_backend=backend,\n                         enable_timing=True)\n\n    start = time.time()\n    wc.assign_surface()\n    elapsed = time.time() - start\n\n    print(f\"{backend:10s}: {elapsed:.4f} s\")\n</code></pre>"},{"location":"api/backends/#backend-comparison","title":"Backend Comparison","text":""},{"location":"api/backends/#benchmark-results","title":"Benchmark Results","text":"<p>System: 10,000 water molecules, alpha=2.4, mesh=2.0</p> Backend Time (s) Speedup Memory (GB) Python 12.450 1.0x 0.8 C++ 0.352 35.4x 0.9 GPU 0.063 197.6x 1.2 (GPU) <p>System: 1,000 water molecules, alpha=2.4, mesh=2.0</p> Backend Time (s) Speedup Memory (GB) Python 2.450 1.0x 0.2 C++ 0.122 20.1x 0.2 GPU 0.156 15.7x 0.5 (GPU) <p>Note: GPU has overhead for small systems!</p>"},{"location":"api/backends/#scaling-behavior","title":"Scaling Behavior","text":"<pre><code>Time vs. Number of Atoms (mesh=2.0, alpha=2.4)\n\n  Python: T \u221d N^1.2\n  C++:    T \u221d N^1.0\n  GPU:    T \u221d N^0.9 (for N &gt; 10k)\n</code></pre>"},{"location":"api/backends/#advanced-custom-backends","title":"Advanced: Custom Backends","text":"<p>You can implement custom backends by subclassing the density evaluator:</p> <pre><code>from pywc.wc_core.density import DensityEvaluator\n\nclass MyCustomBackend(DensityEvaluator):\n    def evaluate(self, positions, grid, box, alpha, weights):\n        # Your custom implementation\n        return density_field\n\n# Use custom backend\nwc = WillardChandler(u, group=atoms, surface_backend=MyCustomBackend())\n</code></pre>"},{"location":"api/backends/#see-also","title":"See Also","text":"<ul> <li>Installation - Installing backends</li> <li>WillardChandler API - Main API reference</li> <li>Examples - Usage examples</li> </ul>"},{"location":"api/willard_chandler/","title":"WillardChandler API Reference","text":"<p>The <code>WillardChandler</code> class is the main interface for computing intrinsic density surfaces.</p>"},{"location":"api/willard_chandler/#class-definition","title":"Class Definition","text":"<pre><code>from pywc import WillardChandler\n\nwc = WillardChandler(\n    universe,\n    group=None,\n    alpha=2.4,\n    mesh=2.0,\n    centered=False,\n    surface_backend='cpp',\n    enable_timing=False,\n    **kwargs\n)\n</code></pre>"},{"location":"api/willard_chandler/#parameters","title":"Parameters","text":""},{"location":"api/willard_chandler/#universe-mdanalysisuniverse","title":"<code>universe</code> (MDAnalysis.Universe)","text":"<p>Required. The MDAnalysis Universe object containing the trajectory.</p> <pre><code>import MDAnalysis as mda\nu = mda.Universe(\"topology.pdb\", \"trajectory.xtc\")\n</code></pre>"},{"location":"api/willard_chandler/#group-mdanalysisatomgroup-optional","title":"<code>group</code> (MDAnalysis.AtomGroup, optional)","text":"<p>The group of atoms to analyze. If <code>None</code>, uses all atoms in the universe.</p> <pre><code># Select specific atoms\ngroup = u.select_atoms(\"resname DPPC and name P\")\n\n# Or use all atoms\ngroup = None  # Will use u.atoms\n</code></pre>"},{"location":"api/willard_chandler/#alpha-float-default24","title":"<code>alpha</code> (float, default=2.4)","text":"<p>Gaussian width parameter in \u00c5ngstr\u00f6ms. Controls the smoothness of the density field.</p> <ul> <li>Range: Typically 1.5 - 4.0 \u00c5</li> <li>Smaller values: Sharper, more detailed surfaces</li> <li>Larger values: Smoother surfaces, less noise</li> </ul> <p>Recommendations: - Water: 2.0 - 2.5 \u00c5 - Lipids: 3.0 - 3.5 \u00c5 - Proteins: 3.0 - 4.0 \u00c5</p> <pre><code>wc = WillardChandler(u, group=water, alpha=2.4)\n</code></pre>"},{"location":"api/willard_chandler/#mesh-float-default20","title":"<code>mesh</code> (float, default=2.0)","text":"<p>Grid spacing in \u00c5ngstr\u00f6ms. Controls the resolution of the density grid.</p> <ul> <li>Range: Typically 1.0 - 3.0 \u00c5</li> <li>Smaller values: Higher resolution, slower</li> <li>Larger values: Lower resolution, faster</li> </ul> <pre><code>wc = WillardChandler(u, group=water, mesh=2.0)\n</code></pre>"},{"location":"api/willard_chandler/#centered-bool-defaultfalse","title":"<code>centered</code> (bool, default=False)","text":"<p>Whether to center the selected group in the simulation box.</p> <ul> <li><code>True</code>: Recommended for most cases</li> <li><code>False</code>: Use if system is already positioned correctly</li> </ul> <pre><code>wc = WillardChandler(u, group=water, centered=True)\n</code></pre>"},{"location":"api/willard_chandler/#surface_backend-str-defaultcpp","title":"<code>surface_backend</code> (str, default='cpp')","text":"<p>Backend for density computation.</p> <p>Options: - <code>'cpp'</code>: C++ with OpenMP (default, recommended) - <code>'cupy'</code>: GPU via CuPy/CUDA - <code>'python'</code>: Pure Python (slow, for testing)</p> <pre><code># CPU backend\nwc_cpu = WillardChandler(u, group=water, surface_backend='cpp')\n\n# GPU backend\nwc_gpu = WillardChandler(u, group=water, surface_backend='cupy')\n</code></pre>"},{"location":"api/willard_chandler/#enable_timing-bool-defaultfalse","title":"<code>enable_timing</code> (bool, default=False)","text":"<p>Enable performance timing diagnostics.</p> <pre><code>wc = WillardChandler(u, group=water, enable_timing=True)\n# ... after computation ...\nprint(f\"Time: {wc.get_timing():.4f} s\")\n</code></pre>"},{"location":"api/willard_chandler/#attributes","title":"Attributes","text":""},{"location":"api/willard_chandler/#triangulated_surface","title":"<code>triangulated_surface</code>","text":"<p>Returns the triangulated surface as a tuple of (vertices, faces, normals).</p> <p>Returns: - <code>vertices</code> (ndarray, shape (N, 3)): Surface vertex coordinates in \u00c5ngstr\u00f6ms - <code>faces</code> (ndarray, shape (M, 3)): Triangle indices - <code>normals</code> (ndarray, shape (N, 3)): Vertex normal vectors</p> <pre><code>vertices, faces, normals = wc.triangulated_surface\n\nprint(f\"Number of vertices: {len(vertices)}\")\nprint(f\"Number of faces: {len(faces)}\")\n</code></pre>"},{"location":"api/willard_chandler/#surface_area","title":"<code>surface_area</code>","text":"<p>Total surface area in \u0172.</p> <pre><code>area = wc.surface_area\nprint(f\"Surface area: {area:.2f} \u0172\")\n</code></pre>"},{"location":"api/willard_chandler/#density_field","title":"<code>density_field</code>","text":"<p>The computed 3D density field on the grid.</p> <p>Returns: ndarray, shape (nx, ny, nz)</p> <pre><code>density = wc.density_field\nprint(f\"Density shape: {density.shape}\")\nprint(f\"Min/Max density: {density.min():.3f} / {density.max():.3f}\")\n</code></pre>"},{"location":"api/willard_chandler/#grid","title":"<code>grid</code>","text":"<p>Grid points where density is evaluated.</p> <p>Returns: ndarray, shape (nx*ny*nz, 3)</p> <pre><code>grid_points = wc.grid\n</code></pre>"},{"location":"api/willard_chandler/#methods","title":"Methods","text":""},{"location":"api/willard_chandler/#assign_surface","title":"<code>assign_surface()</code>","text":"<p>Compute the surface for the current frame.</p> <pre><code>wc.assign_surface()\n</code></pre> <p>Use case: Call this when iterating over trajectory frames:</p> <pre><code>for ts in u.trajectory:\n    wc.assign_surface()\n    area = wc.surface_area\n    print(f\"Frame {ts.frame}: {area:.2f} \u0172\")\n</code></pre>"},{"location":"api/willard_chandler/#get_timing","title":"<code>get_timing()</code>","text":"<p>Get the total computation time (if <code>enable_timing=True</code>).</p> <p>Returns: float - Time in seconds</p> <pre><code>wc = WillardChandler(u, group=water, enable_timing=True)\nwc.assign_surface()\ntime = wc.get_timing()\nprint(f\"Computation time: {time:.4f} s\")\n</code></pre>"},{"location":"api/willard_chandler/#writevtksurfacefilename","title":"<code>writevtk.surface(filename)</code>","text":"<p>Export surface to VTK format.</p> <p>Parameters: - <code>filename</code> (str): Output file path</p> <pre><code>wc.writevtk.surface(\"surface.vtk\")\n</code></pre>"},{"location":"api/willard_chandler/#writevtkdensityfilename","title":"<code>writevtk.density(filename)</code>","text":"<p>Export density field to VTK format.</p> <pre><code>wc.writevtk.density(\"density.vtk\")\n</code></pre>"},{"location":"api/willard_chandler/#writevtkatomsfilename","title":"<code>writevtk.atoms(filename)</code>","text":"<p>Export atom positions to VTK format.</p> <pre><code>wc.writevtk.atoms(\"atoms.vtk\")\n</code></pre>"},{"location":"api/willard_chandler/#writeobjfilename","title":"<code>writeobj(filename)</code>","text":"<p>Export surface to Wavefront OBJ format.</p> <pre><code>wc.writeobj(\"surface.obj\")\n</code></pre>"},{"location":"api/willard_chandler/#writecubefilename","title":"<code>writecube(filename)</code>","text":"<p>Export density to Gaussian Cube format.</p> <pre><code>wc.writecube(\"density.cube\")\n</code></pre>"},{"location":"api/willard_chandler/#writepdbsurfacefilename","title":"<code>writepdb.surface(filename)</code>","text":"<p>Export surface vertices as PDB.</p> <pre><code>wc.writepdb.surface(\"surface.pdb\")\n</code></pre>"},{"location":"api/willard_chandler/#complete-example","title":"Complete Example","text":"<pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport numpy as np\n\n# Load trajectory\nu = mda.Universe(\"system.pdb\", \"traj.xtc\")\nlipids = u.select_atoms(\"resname DPPC and name P\")\n\n# Create WillardChandler object\nwc = WillardChandler(\n    u,\n    group=lipids,\n    alpha=3.0,\n    mesh=2.0,\n    centered=True,\n    surface_backend='cpp',\n    enable_timing=True\n)\n\n# Analyze trajectory\nareas = []\nfor ts in u.trajectory[::10]:  # Every 10th frame\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n\n    # Export every 100th frame\n    if ts.frame % 100 == 0:\n        wc.writevtk.surface(f\"surface_frame_{ts.frame}.vtk\")\n\n# Statistics\nmean_area = np.mean(areas)\nstd_area = np.std(areas)\nprint(f\"Mean area: {mean_area:.2f} \u00b1 {std_area:.2f} \u0172\")\nprint(f\"Average time per frame: {wc.get_timing():.4f} s\")\n\n# Get final surface\nvertices, faces, normals = wc.triangulated_surface\nprint(f\"Final surface: {len(vertices)} vertices, {len(faces)} faces\")\n</code></pre>"},{"location":"api/willard_chandler/#see-also","title":"See Also","text":"<ul> <li>Backends - Backend selection and performance</li> <li>Quick Start - Basic usage examples</li> <li>Examples - Real-world applications</li> </ul>"}]}