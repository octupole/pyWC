{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyWC: Willard-Chandler Surface Analysis Toolkit","text":"[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) [![Python 3.10+](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/) [![GitHub](https://img.shields.io/badge/github-pyWC-blue.svg)](https://github.com/octupole/pyWC)   <p>pyWC is a high-performance Python toolkit for computing and analyzing Willard-Chandler intrinsic density surfaces from molecular dynamics simulations.</p>"},{"location":"#about-this-project","title":"About This Project","text":"<p>This package is a specialized fork of pytim by Marcello Sega and collaborators, focusing exclusively on the Willard-Chandler method with significant performance improvements:</p> <ul> <li>~35x faster KDE evaluation through optimized C++ implementation</li> <li>GPU acceleration via CuPy for large systems (&gt;10k atoms)</li> <li>10-20x faster system centering with OpenMP parallelization</li> <li>Streamlined codebase by removing unused modules</li> </ul> <p>Upstream Project</p> <ul> <li>Original: Marcello-Sega/pytim</li> <li>Paper: Sega, M., Fabian, B., &amp; Jedlovszky, P. (2018). Pytim: A python package for the interfacial analysis of molecular simulations. Journal of Computational Chemistry, 39(25), 2118-2125. DOI: 10.1002/jcc.25384</li> </ul>"},{"location":"#scientific-background","title":"Scientific Background","text":"<p>The Willard-Chandler method identifies intrinsic molecular surfaces by:</p> <ol> <li>Computing a smooth density field via Gaussian kernel density estimation</li> <li>Extracting the isosurface at critical density using marching cubes</li> <li>Providing a triangulated surface representation for analysis</li> </ol> <p>Reference</p> <p>Willard, A. P., &amp; Chandler, D. (2010). Instantaneous liquid interfaces. The Journal of Physical Chemistry B, 114(5), 1954-1958. DOI: 10.1021/jp909219k</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#multi-backend-performance","title":"Multi-Backend Performance","text":"<ul> <li>CPU (C++): OpenMP-parallelized pybind11 extensions (~35x speedup)</li> <li>GPU (CUDA): CuPy implementation with custom CUDA kernels</li> <li>Python: Pure NumPy/SciPy fallback for testing</li> </ul>"},{"location":"#core-capabilities","title":"Core Capabilities","text":"<ul> <li>\u2713 Compute intrinsic density fields on structured 3D grids</li> <li>\u2713 Extract triangulated surfaces via marching cubes</li> <li>\u2713 Calculate surface area, bending rigidity, and thickness profiles</li> <li>\u2713 Process entire MD trajectories with frame-to-frame continuity</li> <li>\u2713 Accurate periodic boundary condition handling</li> </ul>"},{"location":"#output-formats","title":"Output Formats","text":"<ul> <li>VTK: For visualization in ParaView, VMD</li> <li>Wavefront OBJ: For 3D graphics software (Blender, etc.)</li> <li>Gaussian Cube: For quantum chemistry packages</li> <li>PDB: For molecular visualization</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load trajectory\nu = mda.Universe(\"system.pdb\", \"trajectory.xtc\")\ngroup = u.select_atoms(\"resname DPPC\")\n\n# Create interface with CPU backend\nwc = WillardChandler(\n    u,\n    group=group,\n    alpha=3.0,           # Gaussian width (\u00c5)\n    mesh=2.0,            # Grid spacing (\u00c5)\n    centered=True,       # Center the group\n    surface_backend='cpp'\n)\n\n# Get surface\nvertices, faces, normals = wc.triangulated_surface\nprint(f\"Surface area: {wc.surface_area:.2f} \u0172\")\n\n# Export\nwc.writevtk.surface(\"surface.vtk\")\n</code></pre>"},{"location":"#performance-benchmarks","title":"Performance Benchmarks","text":"System Size Backend Time (s) Speedup 1,000 atoms Python 2.45 1x 1,000 atoms C++ 0.12 20x 10,000 atoms C++ 1.85 - 10,000 atoms GPU 0.32 5.8x <p>Benchmarks on AMD Ryzen 5950X (C++) and NVIDIA RTX 3090 (GPU)</p>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Membrane biophysics: Lipid bilayer surface characterization</li> <li>Liquid interfaces: Water/vapor, oil/water surfaces</li> <li>Protein-membrane interactions: Binding site identification</li> <li>Nanoparticle analysis: Micelle and vesicle shapes</li> <li>Material science: Polymer surfaces, nanostructures</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start? Check out the Installation Guide and Quick Start Tutorial.</p>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository: octupole/pyWC</li> <li>Report Issues: GitHub Issues</li> <li>Contribute: See our Contributing Guide</li> <li>Contact: Massimo Marchi (massimo@octupole.org)</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 (GPL-3.0) - the same license as the upstream pytim project.</p>"},{"location":"citation/","title":"Citation","text":"<p>If you use pyWC in your research, please cite both this fork and the original pytim paper.</p>"},{"location":"citation/#citing-pywc","title":"Citing pyWC","text":""},{"location":"citation/#bibtex-entry","title":"BibTeX Entry","text":"<pre><code>@software{pywc2025,\n  author = {Marchi, Massimo},\n  title = {pyWC: Willard-Chandler Surface Analysis Toolkit},\n  year = {2025},\n  url = {https://github.com/octupole/pyWC},\n  version = {1.0.4+wc},\n  note = {Fork of pytim focused on Willard-Chandler method with performance enhancements}\n}\n</code></pre>"},{"location":"citation/#in-text","title":"In Text","text":"<p>Marchi, M. (2025). pyWC: Willard-Chandler Surface Analysis Toolkit (Version 1.0.4+wc) [Computer software]. https://github.com/octupole/pyWC</p>"},{"location":"citation/#citing-original-pytim","title":"Citing Original pytim","text":"<p>You must also cite the original pytim paper:</p> <pre><code>@article{pytim2018,\n  author = {Sega, Marcello and Fabian, Balazs and Jedlovszky, P\u00e1l},\n  title = {Pytim: A python package for the interfacial analysis of molecular simulations},\n  journal = {Journal of Computational Chemistry},\n  volume = {39},\n  number = {25},\n  pages = {2118-2125},\n  year = {2018},\n  doi = {10.1002/jcc.25384},\n  url = {https://doi.org/10.1002/jcc.25384}\n}\n</code></pre>"},{"location":"citation/#in-text_1","title":"In Text","text":"<p>Sega, M., Fabian, B., &amp; Jedlovszky, P. (2018). Pytim: A python package for the interfacial analysis of molecular simulations. Journal of Computational Chemistry, 39(25), 2118-2125. https://doi.org/10.1002/jcc.25384</p>"},{"location":"citation/#citing-willard-chandler-method","title":"Citing Willard-Chandler Method","text":"<p>For the original Willard-Chandler method:</p> <pre><code>@article{willard2010,\n  author = {Willard, Adam P. and Chandler, David},\n  title = {Instantaneous liquid interfaces},\n  journal = {The Journal of Physical Chemistry B},\n  volume = {114},\n  number = {5},\n  pages = {1954-1958},\n  year = {2010},\n  doi = {10.1021/jp909219k},\n  url = {https://doi.org/10.1021/jp909219k}\n}\n</code></pre>"},{"location":"citation/#in-text_2","title":"In Text","text":"<p>Willard, A. P., &amp; Chandler, D. (2010). Instantaneous liquid interfaces. The Journal of Physical Chemistry B, 114(5), 1954-1958. https://doi.org/10.1021/jp909219k</p>"},{"location":"citation/#complete-citation-example","title":"Complete Citation Example","text":"<p>In your Methods section:</p> <p>Surface analysis was performed using pyWC v1.0.4+wc (Marchi, 2025), a performance-optimized fork of pytim (Sega et al., 2018), implementing the Willard-Chandler method (Willard &amp; Chandler, 2010) for computing intrinsic density surfaces.</p> <p>In your References:</p> <pre><code>Marchi, M. (2025). pyWC: Willard-Chandler Surface Analysis Toolkit\n    (Version 1.0.4+wc) [Computer software]. https://github.com/octupole/pyWC\n\nSega, M., Fabian, B., &amp; Jedlovszky, P. (2018). Pytim: A python package\n    for the interfacial analysis of molecular simulations. Journal of\n    Computational Chemistry, 39(25), 2118-2125.\n    https://doi.org/10.1002/jcc.25384\n\nWillard, A. P., &amp; Chandler, D. (2010). Instantaneous liquid interfaces.\n    The Journal of Physical Chemistry B, 114(5), 1954-1958.\n    https://doi.org/10.1021/jp909219k\n</code></pre>"},{"location":"citation/#github-citation-feature","title":"GitHub Citation Feature","text":"<p>GitHub automatically generates citations from the <code>CITATION.cff</code> file. On the pyWC repository page, click the \"Cite this repository\" button in the sidebar to get formatted citations.</p>"},{"location":"citation/#additional-citations","title":"Additional Citations","text":""},{"location":"citation/#for-gpu-implementation","title":"For GPU Implementation","text":"<p>If you specifically used the GPU backend:</p> <pre><code>@software{cupy,\n  author = {{CuPy Development Team}},\n  title = {CuPy: NumPy \\&amp; SciPy for GPU},\n  year = {2023},\n  url = {https://cupy.dev/},\n}\n</code></pre>"},{"location":"citation/#for-mdanalysis","title":"For MDAnalysis","text":"<p>If using MDAnalysis for trajectory handling:</p> <pre><code>@article{mdanalysis2016,\n  author = {Gowers, Richard J. and Linke, Max and Barnoud, Jonathan and\n            Reddy, Tyler J. E. and Melo, Manuel N. and Seyler, Sean L. and\n            Doma\u0144ski, Jan and Dotson, David L. and Buchoux, S\u00e9bastien and\n            Kenney, Ian M. and Beckstein, Oliver},\n  title = {{MDAnalysis}: A Python Package for the Rapid Analysis of\n           Molecular Dynamics Simulations},\n  journal = {Proceedings of the 15th Python in Science Conference},\n  pages = {98-105},\n  year = {2016},\n  doi = {10.25080/Majora-629e541a-00e}\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":""},{"location":"citation/#in-your-manuscript","title":"In Your Manuscript","text":"<p>Consider adding an acknowledgment:</p> <p>We thank Marcello Sega and collaborators for developing the original pytim package, upon which this work builds. We also acknowledge the developers of MDAnalysis, NumPy, SciPy, and scikit-image for providing essential software infrastructure.</p>"},{"location":"citation/#questions","title":"Questions?","text":"<p>For citation questions or if you'd like to discuss how pyWC was used in your research, please contact:</p> <p>Massimo Marchi - Email: massimo@octupole.org - GitHub: @octupole</p>"},{"location":"citation/#related-software","title":"Related Software","text":"<p>If you used other tools in your analysis pipeline, consider citing:</p> <ul> <li>ParaView: For visualization</li> <li>VMD: For molecular visualization</li> <li>NumPy/SciPy: For numerical computing</li> <li>scikit-image: For marching cubes algorithm</li> </ul>"},{"location":"contributing/","title":"Contributing to pyWC","text":"<p>Thank you for considering contributing to pyWC! This page provides guidelines for contributing to the project.</p> <p>For the complete contribution guide, please see CONTRIBUTING.md in the repository.</p>"},{"location":"contributing/#quick-links","title":"Quick Links","text":"<ul> <li>Report Bugs: GitHub Issues</li> <li>Suggest Features: GitHub Issues</li> <li>Repository: github.com/octupole/pyWC</li> </ul>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code>git clone https://github.com/octupole/pyWC.git\ncd pyWC\n</code></pre>"},{"location":"contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\npip install -e .[dev,gpu]\n</code></pre>"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write clear, documented code</li> <li>Follow existing code style (PEP 8)</li> <li>Add tests if applicable</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#4-submit-pull-request","title":"4. Submit Pull Request","text":"<pre><code>git checkout -b feature/your-feature\ngit add .\ngit commit -m \"Description of changes\"\ngit push origin feature/your-feature\n</code></pre> <p>Then open a pull request on GitHub.</p>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":"<p>We especially welcome contributions in:</p> <ul> <li>Performance improvements: GPU optimizations, SIMD vectorization</li> <li>Documentation: Examples, tutorials, API docs</li> <li>Testing: Expanded test coverage, benchmarks</li> <li>Features: New analysis metrics, output formats</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Accept constructive criticism</li> <li>Focus on what's best for the community</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue for questions</li> <li>Email: massimo@octupole.org</li> <li>See full guide: CONTRIBUTING.md</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page provides real-world examples of using pyWC for different molecular systems.</p>"},{"location":"examples/#watervapor-interface","title":"Water/Vapor Interface","text":"<p>Analyze a liquid-vapor interface:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport numpy as np\n\n# Load water system\nu = mda.Universe(\"water.gro\", \"water.xtc\")\nwater = u.select_atoms(\"resname SOL\")\n\n# Create WillardChandler object\nwc = WillardChandler(\n    u,\n    group=water,\n    alpha=2.4,        # Standard for water\n    mesh=2.0,\n    centered=True,\n    surface_backend='cpp'\n)\n\n# Analyze trajectory\nareas = []\nfor ts in u.trajectory:\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n\n# Statistics\nprint(f\"Mean area: {np.mean(areas):.2f} \u00b1 {np.std(areas):.2f} \u0172\")\n\n# Export final frame\nwc.writevtk.surface(\"water_surface.vtk\")\n</code></pre>"},{"location":"examples/#lipid-bilayer","title":"Lipid Bilayer","text":"<p>Characterize membrane surfaces:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load DPPC bilayer\nu = mda.Universe(\"dppc.gro\", \"dppc.xtc\")\n\n# Select phosphate groups (headgroups)\nupper_leaflet = u.select_atoms(\"resname DPPC and name P and prop z &gt; 0\")\nlower_leaflet = u.select_atoms(\"resname DPPC and name P and prop z &lt; 0\")\n\n# Analyze upper leaflet\nwc_upper = WillardChandler(\n    u,\n    group=upper_leaflet,\n    alpha=3.0,        # Larger for lipids\n    mesh=2.0,\n    centered=False    # Leaflets already positioned\n)\n\nwc_upper.assign_surface()\nprint(f\"Upper leaflet area: {wc_upper.surface_area:.2f} \u0172\")\n\n# Analyze lower leaflet\nwc_lower = WillardChandler(\n    u,\n    group=lower_leaflet,\n    alpha=3.0,\n    mesh=2.0\n)\n\nwc_lower.assign_surface()\nprint(f\"Lower leaflet area: {wc_lower.surface_area:.2f} \u0172\")\n\n# Export both surfaces\nwc_upper.writevtk.surface(\"upper_leaflet.vtk\")\nwc_lower.writevtk.surface(\"lower_leaflet.vtk\")\n</code></pre>"},{"location":"examples/#micelle-analysis","title":"Micelle Analysis","text":"<p>Analyze surfactant micelle:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport matplotlib.pyplot as plt\n\n# Load DPC micelle\nu = mda.Universe(\"micelle.pdb\")\nheadgroups = u.select_atoms(\"resname DPC and name N\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=headgroups,\n    alpha=3.0,\n    mesh=2.0,\n    centered=True\n)\n\n# Get surface\nvertices, faces, normals = wc.triangulated_surface\n\n# Calculate radius distribution\ncenter = vertices.mean(axis=0)\nradii = np.linalg.norm(vertices - center, axis=1)\n\nprint(f\"Mean radius: {radii.mean():.2f} \u00b1 {radii.std():.2f} \u00c5\")\n\n# Plot radius distribution\nplt.hist(radii, bins=30)\nplt.xlabel(\"Radius (\u00c5)\")\nplt.ylabel(\"Count\")\nplt.savefig(\"micelle_radius_dist.png\")\n\n# Export\nwc.writeobj(\"micelle.obj\")\n</code></pre>"},{"location":"examples/#protein-surface","title":"Protein Surface","text":"<p>Compute protein surface:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load protein system\nu = mda.Universe(\"protein.pdb\", \"protein.xtc\")\nprotein = u.select_atoms(\"protein\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=protein,\n    alpha=3.5,        # Larger for proteins\n    mesh=2.5,\n    centered=True,\n    surface_backend='cpp'\n)\n\n# Process trajectory\nfor ts in u.trajectory[::10]:  # Every 10th frame\n    wc.assign_surface()\n    area = wc.surface_area\n    print(f\"Frame {ts.frame:4d}: Area = {area:.2f} \u0172\")\n\n    # Save snapshots\n    if ts.frame % 100 == 0:\n        wc.writevtk.surface(f\"protein_{ts.frame:04d}.vtk\")\n</code></pre>"},{"location":"examples/#gpu-backend-for-large-systems","title":"GPU Backend for Large Systems","text":"<p>Use GPU acceleration for large systems:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport time\n\n# Load large system\nu = mda.Universe(\"large_system.gro\", \"large_system.xtc\")\natoms = u.select_atoms(\"all\")\n\nprint(f\"System size: {len(atoms)} atoms\")\n\n# Compare backends\nfor backend in ['cpp', 'cupy']:\n    try:\n        wc = WillardChandler(\n            u,\n            group=atoms,\n            alpha=2.4,\n            mesh=2.0,\n            surface_backend=backend,\n            enable_timing=True\n        )\n\n        start = time.time()\n        wc.assign_surface()\n        elapsed = time.time() - start\n\n        print(f\"{backend:10s}: {elapsed:.4f} s, Area = {wc.surface_area:.2f} \u0172\")\n\n    except Exception as e:\n        print(f\"{backend:10s}: Not available ({e})\")\n</code></pre>"},{"location":"examples/#trajectory-analysis-with-plotting","title":"Trajectory Analysis with Plotting","text":"<p>Analyze surface evolution over time:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load trajectory\nu = mda.Universe(\"system.gro\", \"trajectory.xtc\")\ngroup = u.select_atoms(\"resname DPPC and name P\")\n\n# Create WillardChandler\nwc = WillardChandler(\n    u, group=group,\n    alpha=3.0, mesh=2.0,\n    centered=True\n)\n\n# Collect data\ntimes = []\nareas = []\nn_vertices = []\n\nfor ts in u.trajectory[::5]:  # Every 5th frame\n    wc.assign_surface()\n\n    times.append(ts.time)\n    areas.append(wc.surface_area)\n\n    vertices, _, _ = wc.triangulated_surface\n    n_vertices.append(len(vertices))\n\n# Convert to arrays\ntimes = np.array(times)\nareas = np.array(areas)\nn_vertices = np.array(n_vertices)\n\n# Plot\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n\n# Surface area\nax1.plot(times, areas, 'b-', linewidth=0.5, alpha=0.7)\nax1.axhline(areas.mean(), color='r', linestyle='--',\n            label=f'Mean: {areas.mean():.1f} \u0172')\nax1.fill_between(times,\n                 areas.mean()-areas.std(),\n                 areas.mean()+areas.std(),\n                 alpha=0.2, color='r')\nax1.set_ylabel('Surface Area (\u0172)')\nax1.legend()\nax1.grid(alpha=0.3)\n\n# Number of vertices\nax2.plot(times, n_vertices, 'g-', linewidth=0.5, alpha=0.7)\nax2.set_xlabel('Time (ps)')\nax2.set_ylabel('Number of Vertices')\nax2.grid(alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('surface_analysis.png', dpi=300)\n\n# Statistics\nprint(f\"Area: {areas.mean():.2f} \u00b1 {areas.std():.2f} \u0172\")\nprint(f\"Vertices: {n_vertices.mean():.0f} \u00b1 {n_vertices.std():.0f}\")\n</code></pre>"},{"location":"examples/#computing-bending-rigidity","title":"Computing Bending Rigidity","text":"<p>Use the built-in script:</p> <pre><code>pywc-bending-rigidity \\\n    --topology system.gro \\\n    --trajectory traj.xtc \\\n    --selection \"resname DPPC and name P\" \\\n    --alpha 3.0 \\\n    --mesh 2.0 \\\n    --output bending_rigidity.csv\n</code></pre> <p>Or from Python:</p> <pre><code>from scripts.compute_bending_rigidity import analyze_bending_rigidity\n\nresults = analyze_bending_rigidity(\n    topology=\"system.gro\",\n    trajectory=\"traj.xtc\",\n    selection=\"resname DPPC and name P\",\n    alpha=3.0,\n    mesh=2.0\n)\n\nprint(f\"Bending modulus: {results['kappa']:.3f} kT\")\n</code></pre>"},{"location":"examples/#thickness-mapping","title":"Thickness Mapping","text":"<p>Compute membrane thickness:</p> <pre><code>from scripts.compute_willard_chandler_area import compute_thickness_map\n\nthickness_map = compute_thickness_map(\n    topology=\"bilayer.gro\",\n    trajectory=\"bilayer.xtc\",\n    selection_upper=\"resname DPPC and name P and prop z &gt; 0\",\n    selection_lower=\"resname DPPC and name P and prop z &lt; 0\",\n    grid_spacing=2.0\n)\n\n# Visualize\nimport matplotlib.pyplot as plt\n\nplt.imshow(thickness_map, cmap='viridis', origin='lower')\nplt.colorbar(label='Thickness (\u00c5)')\nplt.xlabel('X (grid points)')\nplt.ylabel('Y (grid points)')\nplt.title('Membrane Thickness Map')\nplt.savefig('thickness_map.png', dpi=300)\n</code></pre>"},{"location":"examples/#export-to-multiple-formats","title":"Export to Multiple Formats","text":"<pre><code>from pywc import WillardChandler\n\n# ... create and compute surface ...\n\n# VTK for ParaView\nwc.writevtk.surface(\"surface.vtk\")\nwc.writevtk.density(\"density.vtk\")\nwc.writevtk.atoms(\"atoms.vtk\")\n\n# Wavefront OBJ for Blender\nwc.writeobj(\"surface.obj\")\n\n# Gaussian Cube for quantum chemistry\nwc.writecube(\"density.cube\")\n\n# PDB for molecular viewers\nwc.writepdb.surface(\"surface.pdb\")\n</code></pre>"},{"location":"examples/#custom-analysis","title":"Custom Analysis","text":"<p>Extract surface properties for custom analysis:</p> <pre><code>from pywc import WillardChandler\nimport numpy as np\n\n# Compute surface\nwc = WillardChandler(u, group=atoms, alpha=2.4, mesh=2.0)\nvertices, faces, normals = wc.triangulated_surface\n\n# Calculate local curvature\ndef compute_curvature(vertices, faces):\n    # Custom curvature calculation\n    # (simplified example)\n    curvatures = []\n    for i, vertex in enumerate(vertices):\n        # Find neighboring faces\n        neighbor_faces = faces[np.any(faces == i, axis=1)]\n        # Compute local curvature\n        # ... your calculation ...\n        curvatures.append(curvature_value)\n    return np.array(curvatures)\n\ncurvatures = compute_curvature(vertices, faces)\n\n# Visualize\nimport matplotlib.pyplot as plt\nplt.hist(curvatures, bins=50)\nplt.xlabel('Curvature (1/\u00c5)')\nplt.ylabel('Count')\nplt.savefig('curvature_distribution.png')\n</code></pre>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Quick Start - Basic usage</li> <li>Backends - Backend selection guide</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This guide covers installing pyWC on different platforms and configurations.</p>"},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: \u2265 3.10</li> <li>C++ Compiler: Supporting C++17 (GCC 7+, Clang 5+, MSVC 2017+)</li> <li>OpenMP: For CPU parallelization</li> </ul>"},{"location":"installation/#platform-support","title":"Platform Support","text":"<ul> <li>Linux (tested on Ubuntu 20.04+, Fedora, Arch)</li> <li>macOS (tested on 11.0+, both Intel and Apple Silicon)</li> <li>Windows (tested on Windows 10/11 with Visual Studio 2017+)</li> </ul>"},{"location":"installation/#basic-installation-cpu-only","title":"Basic Installation (CPU Only)","text":""},{"location":"installation/#from-source","title":"From Source","text":"<p>Clone the repository and install:</p> <pre><code>git clone https://github.com/octupole/pyWC.git\ncd pyWC\npip install .\n</code></pre> <p>This will: - Build C++ extensions with OpenMP support - Install all required dependencies - Make command-line tools available</p>"},{"location":"installation/#dependencies-installed","title":"Dependencies Installed","text":"<p>The basic installation includes:</p> <ul> <li><code>numpy</code> \u2265 2.1.3 - Numerical arrays</li> <li><code>scipy</code> \u2265 1.11.3 - Scientific computing</li> <li><code>scikit-image</code> \u2265 0.24.0 - Marching cubes algorithm</li> <li><code>MDAnalysis</code> \u2265 2.8.0 - Trajectory I/O</li> <li><code>packaging</code> \u2265 23.0 - Version handling</li> </ul>"},{"location":"installation/#build-dependencies","title":"Build Dependencies","text":"<p>The following are needed at build time:</p> <ul> <li><code>pybind11</code> \u2265 2.11 - C++/Python bindings</li> <li><code>Cython</code> - For DBSCAN extension</li> <li><code>setuptools</code> \u2265 61.0</li> <li><code>wheel</code></li> </ul> <p>These are automatically installed during the build process.</p>"},{"location":"installation/#gpu-acceleration-optional","title":"GPU Acceleration (Optional)","text":"<p>For GPU support on NVIDIA GPUs:</p>"},{"location":"installation/#step-1-install-cuda-toolkit","title":"Step 1: Install CUDA Toolkit","text":"<p>Download and install from NVIDIA CUDA Downloads.</p> <p>Verify installation: <pre><code>nvcc --version\nnvidia-smi\n</code></pre></p>"},{"location":"installation/#step-2-install-cupy","title":"Step 2: Install CuPy","text":"<p>Choose the appropriate CuPy package for your CUDA version:</p> CUDA 12.xCUDA 11.xAuto-detect <pre><code>pip install cupy-cuda12x\n</code></pre> <pre><code>pip install cupy-cuda11x\n</code></pre> <pre><code>pip install cupy\n</code></pre>"},{"location":"installation/#step-3-install-pywc-with-gpu-support","title":"Step 3: Install pyWC with GPU Support","text":"<pre><code>pip install .[gpu]\n</code></pre> <p>Or if installing from source with CUDA detected: <pre><code>pip install .  # Automatically includes CuPy if CUDA is detected\n</code></pre></p>"},{"location":"installation/#skip-gpu-installation","title":"Skip GPU Installation","text":"<p>If you have CUDA but don't want GPU support:</p> <pre><code>export PYWC_SKIP_CUPY=1\npip install .\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> <pre><code>git clone https://github.com/octupole/pyWC.git\ncd pyWC\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install in editable mode with dev dependencies\npip install -e .[dev,gpu]\n</code></pre> <p>This installs additional tools: - <code>nose</code> - Testing framework - <code>coverage</code> - Code coverage analysis</p>"},{"location":"installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"installation/#linux","title":"Linux","text":""},{"location":"installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install build dependencies\nsudo apt-get update\nsudo apt-get install build-essential python3-dev libomp-dev\n\n# Install pyWC\npip install .\n</code></pre>"},{"location":"installation/#fedorarhel","title":"Fedora/RHEL","text":"<pre><code># Install build dependencies\nsudo dnf install gcc-c++ python3-devel libomp-devel\n\n# Install pyWC\npip install .\n</code></pre>"},{"location":"installation/#arch-linux","title":"Arch Linux","text":"<pre><code># Install build dependencies\nsudo pacman -S base-devel python openmp\n\n# Install pyWC\npip install .\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":""},{"location":"installation/#install-homebrew-if-not-installed","title":"Install Homebrew (if not installed)","text":"<pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre>"},{"location":"installation/#install-openmp","title":"Install OpenMP","text":"<pre><code>brew install libomp\n</code></pre>"},{"location":"installation/#install-pywc","title":"Install pyWC","text":"<pre><code>pip install .\n</code></pre> <p>Apple Silicon (M1/M2/M3)</p> <p>pyWC works on Apple Silicon Macs. Use Python from Homebrew or miniforge for best compatibility: <pre><code>brew install python@3.11\n# or\nbrew install miniforge\n</code></pre></p>"},{"location":"installation/#windows","title":"Windows","text":""},{"location":"installation/#install-visual-studio","title":"Install Visual Studio","text":"<ol> <li>Download Visual Studio 2022 Community</li> <li>During installation, select:</li> <li>\"Desktop development with C++\"</li> <li>Ensure \"MSVC v143\" and \"Windows 10 SDK\" are checked</li> </ol>"},{"location":"installation/#install-python","title":"Install Python","text":"<p>Download from python.org or use Anaconda.</p>"},{"location":"installation/#install-pywc_1","title":"Install pyWC","text":"<pre><code>pip install .\n</code></pre> <p>Windows Subsystem for Linux (WSL)</p> <p>For best experience on Windows, consider using WSL2 with Ubuntu: <pre><code>wsl --install -d Ubuntu-22.04\n</code></pre> Then follow Linux installation instructions.</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"installation/#test-basic-import","title":"Test Basic Import","text":"<pre><code>python -c \"from pywc import WillardChandler; print('pyWC installed successfully!')\"\n</code></pre>"},{"location":"installation/#test-c-extensions","title":"Test C++ Extensions","text":"<pre><code>from pywc import WillardChandler\nfrom pywc._wc_kde import evaluate_pbc_fast_auto\nprint(\"C++ extensions loaded successfully!\")\n</code></pre>"},{"location":"installation/#test-gpu-support-if-installed","title":"Test GPU Support (if installed)","text":"<pre><code>from pywc.center_gpu import center_gpu\nprint(\"GPU support available!\")\n</code></pre>"},{"location":"installation/#run-command-line-tools","title":"Run Command-Line Tools","text":"<pre><code>pywc-compare-wc-backends --help\npywc-wc-area --help\npywc-bending-rigidity --help\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#openmp-not-found","title":"OpenMP Not Found","text":"LinuxmacOSWindows <pre><code>sudo apt-get install libomp-dev  # Ubuntu/Debian\nsudo dnf install libomp-devel    # Fedora/RHEL\n</code></pre> <pre><code>brew install libomp\n</code></pre> <p>Visual Studio includes OpenMP support. Ensure you selected \"Desktop development with C++\".</p>"},{"location":"installation/#cuda-not-detected","title":"CUDA Not Detected","text":"<pre><code># Set CUDA_HOME environment variable\nexport CUDA_HOME=/usr/local/cuda         # Linux\nexport CUDA_HOME=/opt/cuda              # Some Linux systems\nset CUDA_HOME=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.0  # Windows\n</code></pre>"},{"location":"installation/#compilation-errors","title":"Compilation Errors","text":"<p>If you encounter compilation errors:</p> <ol> <li> <p>Update build tools: <pre><code>pip install --upgrade pip setuptools wheel\n</code></pre></p> </li> <li> <p>Install specific pybind11 version: <pre><code>pip install pybind11==2.11.1\n</code></pre></p> </li> <li> <p>Clean build: <pre><code>rm -rf build/ dist/ *.egg-info\npip install .\n</code></pre></p> </li> </ol>"},{"location":"installation/#import-errors","title":"Import Errors","text":"<p>If you get import errors after installation:</p> <pre><code># Ensure you're not in the source directory\ncd ~\npython -c \"import pywc; print(pywc.__version__)\"\n</code></pre>"},{"location":"installation/#performance-issues","title":"Performance Issues","text":"<p>If C++ extensions are not being used:</p> <pre><code>import pywc\nprint(pywc._center_impl.HAS_CENTER_FAST)  # Should be True\nprint(pywc._center_impl.HAS_CENTER_GPU)   # True if CuPy installed\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn basic usage</li> <li>API Reference - Detailed API documentation</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with pyWC in just a few minutes.</p>"},{"location":"quickstart/#your-first-surface-calculation","title":"Your First Surface Calculation","text":""},{"location":"quickstart/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>pyWC works with any trajectory format supported by MDAnalysis (GROMACS, CHARMM, LAMMPS, AMBER, etc.).</p> <p>For this tutorial, we'll use a sample water system included with pyWC:</p> <pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load the sample water/vapor system\nu = mda.Universe(\"pywc/data/water.gro\", \"pywc/data/water.xtc\")\n</code></pre>"},{"location":"quickstart/#step-2-select-atoms","title":"Step 2: Select Atoms","text":"<p>Select the group of atoms you want to analyze:</p> <pre><code># Select all water molecules\nwater = u.select_atoms(\"resname SOL\")\n\nprint(f\"Selected {len(water)} atoms\")\n</code></pre>"},{"location":"quickstart/#step-3-create-willardchandler-object","title":"Step 3: Create WillardChandler Object","text":"<pre><code>wc = WillardChandler(\n    u,\n    group=water,\n    alpha=2.4,           # Gaussian width in \u00c5ngstr\u00f6ms\n    mesh=2.0,            # Grid spacing in \u00c5ngstr\u00f6ms\n    centered=True,       # Center the system\n    surface_backend='cpp' # Use C++ backend\n)\n</code></pre>"},{"location":"quickstart/#step-4-compute-and-analyze-surface","title":"Step 4: Compute and Analyze Surface","text":"<pre><code># Get triangulated surface\nvertices, faces, normals = wc.triangulated_surface\n\n# Get surface area\nprint(f\"Surface area: {wc.surface_area:.2f} \u0172\")\n\n# Export to VTK for visualization\nwc.writevtk.surface(\"water_surface.vtk\")\n</code></pre> <p>That's it! You've computed your first Willard-Chandler surface.</p>"},{"location":"quickstart/#understanding-the-parameters","title":"Understanding the Parameters","text":""},{"location":"quickstart/#alpha-gaussian-width","title":"<code>alpha</code> - Gaussian Width","text":"<p>Controls the smoothness of the density field:</p> <ul> <li>Smaller values (1.5-2.5 \u00c5): Sharper, more detailed surfaces</li> <li>Larger values (3.0-4.0 \u00c5): Smoother surfaces, less noise</li> </ul> <p>Rule of thumb: Start with 2-3 \u00c5 for water, 3-4 \u00c5 for lipids.</p> <pre><code># Sharp surface\nwc_sharp = WillardChandler(u, group=water, alpha=2.0, mesh=2.0)\n\n# Smooth surface\nwc_smooth = WillardChandler(u, group=water, alpha=4.0, mesh=2.0)\n</code></pre>"},{"location":"quickstart/#mesh-grid-spacing","title":"<code>mesh</code> - Grid Spacing","text":"<p>Controls the resolution of the density grid:</p> <ul> <li>Smaller values (1.0-1.5 \u00c5): Higher resolution, slower computation</li> <li>Larger values (2.0-3.0 \u00c5): Lower resolution, faster computation</li> </ul> <p>Rule of thumb: Use 2.0 \u00c5 for most applications.</p> <pre><code># High resolution (slower)\nwc_highres = WillardChandler(u, group=water, alpha=2.4, mesh=1.0)\n\n# Standard resolution\nwc_standard = WillardChandler(u, group=water, alpha=2.4, mesh=2.0)\n</code></pre>"},{"location":"quickstart/#centered-system-centering","title":"<code>centered</code> - System Centering","text":"<p>Whether to center the selected group in the simulation box:</p> <ul> <li><code>True</code>: Recommended for most cases, avoids periodic boundary artifacts</li> <li><code>False</code>: Use if system is already properly positioned</li> </ul> <pre><code>wc = WillardChandler(u, group=water, alpha=2.4, mesh=2.0, centered=True)\n</code></pre>"},{"location":"quickstart/#surface_backend-computational-backend","title":"<code>surface_backend</code> - Computational Backend","text":"<p>Choose the backend based on your system size and available hardware:</p> Backend When to Use Performance <code>'cpp'</code> Default, best for most systems ~35x faster than Python <code>'cupy'</code> Large systems (&gt;10k atoms) with NVIDIA GPU ~5-6x faster than C++ <code>'python'</code> Testing, debugging, or when C++ unavailable Baseline <pre><code># CPU backend (default, recommended)\nwc_cpu = WillardChandler(u, group=water, alpha=2.4, mesh=2.0,\n                         surface_backend='cpp')\n\n# GPU backend (requires CuPy)\nwc_gpu = WillardChandler(u, group=water, alpha=2.4, mesh=2.0,\n                         surface_backend='cupy')\n</code></pre>"},{"location":"quickstart/#common-use-cases","title":"Common Use Cases","text":""},{"location":"quickstart/#lipid-bilayer-surfaces","title":"Lipid Bilayer Surfaces","text":"<pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\n\n# Load lipid bilayer simulation\nu = mda.Universe(\"bilayer.gro\", \"bilayer.xtc\")\n\n# Select phosphate groups (headgroups)\nheadgroups = u.select_atoms(\"name P or name PO4\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=headgroups,\n    alpha=3.0,        # Larger alpha for lipids\n    mesh=2.0,\n    centered=True\n)\n\n# Analyze\nprint(f\"Membrane surface area: {wc.surface_area:.2f} \u0172\")\nwc.writevtk.surface(\"membrane.vtk\")\n</code></pre>"},{"location":"quickstart/#protein-surface","title":"Protein Surface","text":"<pre><code># Select protein\nprotein = u.select_atoms(\"protein\")\n\n# Create surface\nwc = WillardChandler(\n    u,\n    group=protein,\n    alpha=3.5,        # Larger for proteins\n    mesh=2.5,\n    centered=True\n)\n\nprint(f\"Protein surface area: {wc.surface_area:.2f} \u0172\")\n</code></pre>"},{"location":"quickstart/#micelle-analysis","title":"Micelle Analysis","text":"<pre><code># Select surfactant headgroups\nsurfactant = u.select_atoms(\"resname DPC and name N\")\n\nwc = WillardChandler(\n    u,\n    group=surfactant,\n    alpha=3.0,\n    mesh=2.0,\n    centered=True\n)\n\n# Export for visualization\nwc.writeobj(\"micelle.obj\")\n</code></pre>"},{"location":"quickstart/#trajectory-analysis","title":"Trajectory Analysis","text":"<p>Process multiple frames to analyze surface evolution:</p> <pre><code>import numpy as np\n\n# Track surface area over time\nareas = []\ntimes = []\n\nfor ts in u.trajectory[::10]:  # Every 10th frame\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n    times.append(ts.time)\n    print(f\"Frame {ts.frame}: Area = {wc.surface_area:.2f} \u0172\")\n\n# Calculate statistics\nmean_area = np.mean(areas)\nstd_area = np.std(areas)\nprint(f\"\\nMean area: {mean_area:.2f} \u00b1 {std_area:.2f} \u0172\")\n\n# Plot\nimport matplotlib.pyplot as plt\nplt.plot(times, areas)\nplt.xlabel(\"Time (ps)\")\nplt.ylabel(\"Surface Area (\u0172)\")\nplt.savefig(\"area_vs_time.png\")\n</code></pre>"},{"location":"quickstart/#exporting-results","title":"Exporting Results","text":""},{"location":"quickstart/#vtk-format-paraview-vmd","title":"VTK Format (ParaView, VMD)","text":"<pre><code># Export surface\nwc.writevtk.surface(\"surface.vtk\")\n\n# Export density field\nwc.writevtk.density(\"density.vtk\")\n\n# Export atoms\nwc.writevtk.atoms(\"atoms.vtk\")\n</code></pre> <p>Visualize in ParaView: 1. Open <code>surface.vtk</code> 2. Apply \"Extract Surface\" filter 3. Color by normals or other properties</p>"},{"location":"quickstart/#wavefront-obj-blender-3d-software","title":"Wavefront OBJ (Blender, 3D Software)","text":"<pre><code>wc.writeobj(\"surface.obj\")\n</code></pre> <p>Open in Blender: 1. File \u2192 Import \u2192 Wavefront (.obj) 2. Select <code>surface.obj</code></p>"},{"location":"quickstart/#gaussian-cube-quantum-chemistry","title":"Gaussian Cube (Quantum Chemistry)","text":"<pre><code>wc.writecube(\"density.cube\")\n</code></pre> <p>Compatible with Gaussian, ORCA, VMD, etc.</p>"},{"location":"quickstart/#pdb-molecular-viewers","title":"PDB (Molecular Viewers)","text":"<pre><code>wc.writepdb.surface(\"surface.pdb\")\n</code></pre>"},{"location":"quickstart/#performance-tips","title":"Performance Tips","text":""},{"location":"quickstart/#enable-timing","title":"Enable Timing","text":"<p>Track performance of different components:</p> <pre><code>wc = WillardChandler(\n    u, group=water,\n    alpha=2.4, mesh=2.0,\n    enable_timing=True\n)\n\n# After computation\nprint(f\"Total time: {wc.get_timing():.4f} s\")\n</code></pre>"},{"location":"quickstart/#choose-appropriate-backend","title":"Choose Appropriate Backend","text":"<pre><code># For small systems (&lt;1000 atoms)\nwc = WillardChandler(u, group=small_group, surface_backend='cpp')\n\n# For large systems (&gt;10000 atoms) with GPU\nwc = WillardChandler(u, group=large_group, surface_backend='cupy')\n</code></pre>"},{"location":"quickstart/#optimize-parameters","title":"Optimize Parameters","text":"<p>Balance accuracy and performance:</p> <pre><code># Fast computation (lower accuracy)\nwc_fast = WillardChandler(u, group=water, alpha=3.0, mesh=3.0)\n\n# High accuracy (slower)\nwc_accurate = WillardChandler(u, group=water, alpha=2.0, mesh=1.0)\n</code></pre>"},{"location":"quickstart/#skip-warmup-frames","title":"Skip Warmup Frames","text":"<p>For trajectory analysis, skip initial equilibration:</p> <pre><code>for ts in u.trajectory[100:]:  # Skip first 100 frames\n    wc.assign_surface()\n    # Analysis...\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - More detailed examples</li> <li>Backends - Deep dive into computational backends</li> <li>Citation - How to cite pyWC in publications</li> </ul>"},{"location":"api/backends/","title":"Computational Backends","text":"<p>pyWC provides three computational backends for density evaluation, each optimized for different use cases.</p>"},{"location":"api/backends/#backend-overview","title":"Backend Overview","text":"Backend Implementation Performance Use Case C++ pybind11 + OpenMP ~35x faster Default, production use GPU CuPy/CUDA ~5-6x faster than C++ Large systems (&gt;10k atoms) Python NumPy/SciPy Baseline Testing, debugging"},{"location":"api/backends/#c-backend","title":"C++ Backend","text":"<p>The default and recommended backend for most applications.</p>"},{"location":"api/backends/#features","title":"Features","text":"<ul> <li>OpenMP parallelization: Uses all available CPU cores</li> <li>Cell-list neighbor search: Efficient neighbor finding with PBC</li> <li>Atomic operations: Thread-safe parallel accumulation</li> <li>~35x speedup over pure Python</li> </ul>"},{"location":"api/backends/#usage","title":"Usage","text":"<pre><code>from pywc import WillardChandler\n\nwc = WillardChandler(\n    u, group=atoms,\n    alpha=2.4, mesh=2.0,\n    surface_backend='cpp'  # Default\n)\n</code></pre>"},{"location":"api/backends/#requirements","title":"Requirements","text":"<ul> <li>C++17 compatible compiler</li> <li>OpenMP support</li> <li>pybind11 \u2265 2.11</li> </ul>"},{"location":"api/backends/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Memory: O(N + grid_size)</li> <li>Time complexity: O(N \u00d7 neighbors)</li> <li>Scales linearly with number of atoms</li> <li>Best for: 100 - 100,000 atoms</li> </ul>"},{"location":"api/backends/#implementation-details","title":"Implementation Details","text":"<p>The C++ backend uses two main algorithms:</p> <p>1. <code>evaluate_pbc_fast_auto()</code> (Recommended) - Self-contained cell-list generation - Automatic neighbor search - ~35x faster than Python - No preprocessing required</p> <p>2. <code>evaluate_pbc_fast()</code> (Legacy) - Accepts pre-computed neighbor lists - Backward compatible with pytim - Slightly slower due to Python overhead</p> <pre><code># Automatic (recommended)\nfrom pywc._wc_kde import evaluate_pbc_fast_auto\n\nresult = evaluate_pbc_fast_auto(\n    positions,    # Atomic positions\n    grid,         # Grid points\n    box,          # Box dimensions\n    alpha,        # Gaussian width\n    weights       # Atomic weights\n)\n</code></pre>"},{"location":"api/backends/#compiler-optimization-flags","title":"Compiler Optimization Flags","text":"<p>The build system uses: - <code>-O3</code>: Aggressive optimization - <code>-std=c++17</code>: Modern C++ features - <code>-fopenmp</code>: OpenMP parallelization</p> <p>On Windows (MSVC): - <code>/O2</code>: Optimization - <code>/std:c++17</code>: C++17 standard - <code>/openmp</code>: OpenMP support</p>"},{"location":"api/backends/#gpu-backend","title":"GPU Backend","text":"<p>For large systems with NVIDIA GPUs.</p>"},{"location":"api/backends/#features_1","title":"Features","text":"<ul> <li>CUDA kernels: Custom GPU kernels for Gaussian accumulation</li> <li>Cell-list on GPU: Neighbor search entirely on device</li> <li>Chunked processing: Manages GPU memory automatically</li> <li>~5-6x faster than C++ for large systems</li> </ul>"},{"location":"api/backends/#usage_1","title":"Usage","text":"<pre><code>wc = WillardChandler(\n    u, group=atoms,\n    alpha=2.4, mesh=2.0,\n    surface_backend='cupy'  # GPU backend\n)\n</code></pre>"},{"location":"api/backends/#requirements_1","title":"Requirements","text":"<ul> <li>NVIDIA GPU with CUDA support (Compute Capability \u2265 6.0)</li> <li>CUDA Toolkit 11.0+</li> <li>CuPy \u2265 12.0</li> </ul>"},{"location":"api/backends/#installation","title":"Installation","text":"<p>See Installation Guide for details.</p>"},{"location":"api/backends/#performance-characteristics_1","title":"Performance Characteristics","text":"<ul> <li>Memory: GPU RAM = O(N + grid_size)</li> <li>Best for: &gt;10,000 atoms</li> <li>Speedup: 5-6x over C++ (system dependent)</li> <li>Overhead: Initial data transfer to GPU</li> </ul>"},{"location":"api/backends/#when-to-use-gpu-backend","title":"When to Use GPU Backend","text":"<p>\u2705 Use GPU when: - System has &gt;10,000 atoms - Processing many frames - NVIDIA GPU available - High throughput needed</p> <p>\u274c Use C++ when: - System has &lt;10,000 atoms - Single frame calculation - No GPU available - CPU has many cores</p>"},{"location":"api/backends/#gpu-memory-management","title":"GPU Memory Management","text":"<p>The GPU backend automatically chunks large grids:</p> <pre><code># For very large systems, adjust chunk size\nimport os\nos.environ['PYWC_GPU_CHUNK_SIZE'] = '5000000'  # Grid points per chunk\n</code></pre>"},{"location":"api/backends/#troubleshooting-gpu","title":"Troubleshooting GPU","text":"<p>Check GPU availability: <pre><code>import cupy as cp\nprint(f\"GPU: {cp.cuda.Device().name}\")\nprint(f\"Memory: {cp.cuda.Device().mem_info[1] / 1e9:.1f} GB\")\n</code></pre></p> <p>Force CPU if GPU fails: <pre><code>try:\n    wc = WillardChandler(u, group=atoms, surface_backend='cupy')\nexcept Exception as e:\n    print(f\"GPU failed: {e}, falling back to CPU\")\n    wc = WillardChandler(u, group=atoms, surface_backend='cpp')\n</code></pre></p>"},{"location":"api/backends/#python-backend","title":"Python Backend","text":"<p>Pure NumPy/SciPy implementation for reference and testing.</p>"},{"location":"api/backends/#features_2","title":"Features","text":"<ul> <li>No compilation required: Works immediately</li> <li>Reference implementation: Validates other backends</li> <li>Cross-platform: Works everywhere Python runs</li> </ul>"},{"location":"api/backends/#usage_2","title":"Usage","text":"<pre><code>wc = WillardChandler(\n    u, group=atoms,\n    alpha=2.4, mesh=2.0,\n    surface_backend='python'\n)\n</code></pre>"},{"location":"api/backends/#when-to-use","title":"When to Use","text":"<ul> <li>Testing/debugging</li> <li>Platforms without C++ compiler</li> <li>Verifying results</li> <li>Understanding algorithm</li> </ul>"},{"location":"api/backends/#performance","title":"Performance","text":"<p>Significantly slower than C++ or GPU backends. Use only for small systems or testing.</p>"},{"location":"api/backends/#backend-selection-strategy","title":"Backend Selection Strategy","text":""},{"location":"api/backends/#automatic-selection","title":"Automatic Selection","text":"<p>pyWC doesn't auto-select backends. Choose explicitly based on your needs:</p> <pre><code>def choose_backend(n_atoms, has_gpu):\n    if has_gpu and n_atoms &gt; 10000:\n        return 'cupy'\n    else:\n        return 'cpp'\n\n# Example\nbackend = choose_backend(len(atoms), HAS_GPU)\nwc = WillardChandler(u, group=atoms, surface_backend=backend)\n</code></pre>"},{"location":"api/backends/#benchmark-your-system","title":"Benchmark Your System","text":"<p>Use the included benchmark tool:</p> <pre><code>pywc-compare-wc-backends\n</code></pre> <p>This will test all available backends on your system and report timings.</p>"},{"location":"api/backends/#from-python","title":"From Python","text":"<pre><code>from pywc import WillardChandler\nimport time\n\nbackends = ['cpp']\ntry:\n    import cupy\n    backends.append('cupy')\nexcept ImportError:\n    pass\n\nfor backend in backends:\n    wc = WillardChandler(u, group=atoms, surface_backend=backend,\n                         enable_timing=True)\n\n    start = time.time()\n    wc.assign_surface()\n    elapsed = time.time() - start\n\n    print(f\"{backend:10s}: {elapsed:.4f} s\")\n</code></pre>"},{"location":"api/backends/#backend-comparison","title":"Backend Comparison","text":""},{"location":"api/backends/#benchmark-results","title":"Benchmark Results","text":"<p>System: 10,000 water molecules, alpha=2.4, mesh=2.0</p> Backend Time (s) Speedup Memory (GB) Python 12.450 1.0x 0.8 C++ 0.352 35.4x 0.9 GPU 0.063 197.6x 1.2 (GPU) <p>System: 1,000 water molecules, alpha=2.4, mesh=2.0</p> Backend Time (s) Speedup Memory (GB) Python 2.450 1.0x 0.2 C++ 0.122 20.1x 0.2 GPU 0.156 15.7x 0.5 (GPU) <p>Note: GPU has overhead for small systems!</p>"},{"location":"api/backends/#scaling-behavior","title":"Scaling Behavior","text":"<pre><code>Time vs. Number of Atoms (mesh=2.0, alpha=2.4)\n\n  Python: T \u221d N^1.2\n  C++:    T \u221d N^1.0\n  GPU:    T \u221d N^0.9 (for N &gt; 10k)\n</code></pre>"},{"location":"api/backends/#advanced-custom-backends","title":"Advanced: Custom Backends","text":"<p>You can implement custom backends by subclassing the density evaluator:</p> <pre><code>from pywc.wc_core.density import DensityEvaluator\n\nclass MyCustomBackend(DensityEvaluator):\n    def evaluate(self, positions, grid, box, alpha, weights):\n        # Your custom implementation\n        return density_field\n\n# Use custom backend\nwc = WillardChandler(u, group=atoms, surface_backend=MyCustomBackend())\n</code></pre>"},{"location":"api/backends/#see-also","title":"See Also","text":"<ul> <li>Installation - Installing backends</li> <li>WillardChandler API - Main API reference</li> <li>Examples - Usage examples</li> </ul>"},{"location":"api/willard_chandler/","title":"WillardChandler API Reference","text":"<p>The <code>WillardChandler</code> class is the main interface for computing intrinsic density surfaces.</p>"},{"location":"api/willard_chandler/#class-definition","title":"Class Definition","text":"<pre><code>from pywc import WillardChandler\n\nwc = WillardChandler(\n    universe,\n    group=None,\n    alpha=2.4,\n    mesh=2.0,\n    centered=False,\n    surface_backend='cpp',\n    enable_timing=False,\n    **kwargs\n)\n</code></pre>"},{"location":"api/willard_chandler/#parameters","title":"Parameters","text":""},{"location":"api/willard_chandler/#universe-mdanalysisuniverse","title":"<code>universe</code> (MDAnalysis.Universe)","text":"<p>Required. The MDAnalysis Universe object containing the trajectory.</p> <pre><code>import MDAnalysis as mda\nu = mda.Universe(\"topology.pdb\", \"trajectory.xtc\")\n</code></pre>"},{"location":"api/willard_chandler/#group-mdanalysisatomgroup-optional","title":"<code>group</code> (MDAnalysis.AtomGroup, optional)","text":"<p>The group of atoms to analyze. If <code>None</code>, uses all atoms in the universe.</p> <pre><code># Select specific atoms\ngroup = u.select_atoms(\"resname DPPC and name P\")\n\n# Or use all atoms\ngroup = None  # Will use u.atoms\n</code></pre>"},{"location":"api/willard_chandler/#alpha-float-default24","title":"<code>alpha</code> (float, default=2.4)","text":"<p>Gaussian width parameter in \u00c5ngstr\u00f6ms. Controls the smoothness of the density field.</p> <ul> <li>Range: Typically 1.5 - 4.0 \u00c5</li> <li>Smaller values: Sharper, more detailed surfaces</li> <li>Larger values: Smoother surfaces, less noise</li> </ul> <p>Recommendations: - Water: 2.0 - 2.5 \u00c5 - Lipids: 3.0 - 3.5 \u00c5 - Proteins: 3.0 - 4.0 \u00c5</p> <pre><code>wc = WillardChandler(u, group=water, alpha=2.4)\n</code></pre>"},{"location":"api/willard_chandler/#mesh-float-default20","title":"<code>mesh</code> (float, default=2.0)","text":"<p>Grid spacing in \u00c5ngstr\u00f6ms. Controls the resolution of the density grid.</p> <ul> <li>Range: Typically 1.0 - 3.0 \u00c5</li> <li>Smaller values: Higher resolution, slower</li> <li>Larger values: Lower resolution, faster</li> </ul> <pre><code>wc = WillardChandler(u, group=water, mesh=2.0)\n</code></pre>"},{"location":"api/willard_chandler/#centered-bool-defaultfalse","title":"<code>centered</code> (bool, default=False)","text":"<p>Whether to center the selected group in the simulation box.</p> <ul> <li><code>True</code>: Recommended for most cases</li> <li><code>False</code>: Use if system is already positioned correctly</li> </ul> <pre><code>wc = WillardChandler(u, group=water, centered=True)\n</code></pre>"},{"location":"api/willard_chandler/#surface_backend-str-defaultcpp","title":"<code>surface_backend</code> (str, default='cpp')","text":"<p>Backend for density computation.</p> <p>Options: - <code>'cpp'</code>: C++ with OpenMP (default, recommended) - <code>'cupy'</code>: GPU via CuPy/CUDA - <code>'python'</code>: Pure Python (slow, for testing)</p> <pre><code># CPU backend\nwc_cpu = WillardChandler(u, group=water, surface_backend='cpp')\n\n# GPU backend\nwc_gpu = WillardChandler(u, group=water, surface_backend='cupy')\n</code></pre>"},{"location":"api/willard_chandler/#enable_timing-bool-defaultfalse","title":"<code>enable_timing</code> (bool, default=False)","text":"<p>Enable performance timing diagnostics.</p> <pre><code>wc = WillardChandler(u, group=water, enable_timing=True)\n# ... after computation ...\nprint(f\"Time: {wc.get_timing():.4f} s\")\n</code></pre>"},{"location":"api/willard_chandler/#attributes","title":"Attributes","text":""},{"location":"api/willard_chandler/#triangulated_surface","title":"<code>triangulated_surface</code>","text":"<p>Returns the triangulated surface as a tuple of (vertices, faces, normals).</p> <p>Returns: - <code>vertices</code> (ndarray, shape (N, 3)): Surface vertex coordinates in \u00c5ngstr\u00f6ms - <code>faces</code> (ndarray, shape (M, 3)): Triangle indices - <code>normals</code> (ndarray, shape (N, 3)): Vertex normal vectors</p> <pre><code>vertices, faces, normals = wc.triangulated_surface\n\nprint(f\"Number of vertices: {len(vertices)}\")\nprint(f\"Number of faces: {len(faces)}\")\n</code></pre>"},{"location":"api/willard_chandler/#surface_area","title":"<code>surface_area</code>","text":"<p>Total surface area in \u0172.</p> <pre><code>area = wc.surface_area\nprint(f\"Surface area: {area:.2f} \u0172\")\n</code></pre>"},{"location":"api/willard_chandler/#density_field","title":"<code>density_field</code>","text":"<p>The computed 3D density field on the grid.</p> <p>Returns: ndarray, shape (nx, ny, nz)</p> <pre><code>density = wc.density_field\nprint(f\"Density shape: {density.shape}\")\nprint(f\"Min/Max density: {density.min():.3f} / {density.max():.3f}\")\n</code></pre>"},{"location":"api/willard_chandler/#grid","title":"<code>grid</code>","text":"<p>Grid points where density is evaluated.</p> <p>Returns: ndarray, shape (nx*ny*nz, 3)</p> <pre><code>grid_points = wc.grid\n</code></pre>"},{"location":"api/willard_chandler/#methods","title":"Methods","text":""},{"location":"api/willard_chandler/#assign_surface","title":"<code>assign_surface()</code>","text":"<p>Compute the surface for the current frame.</p> <pre><code>wc.assign_surface()\n</code></pre> <p>Use case: Call this when iterating over trajectory frames:</p> <pre><code>for ts in u.trajectory:\n    wc.assign_surface()\n    area = wc.surface_area\n    print(f\"Frame {ts.frame}: {area:.2f} \u0172\")\n</code></pre>"},{"location":"api/willard_chandler/#get_timing","title":"<code>get_timing()</code>","text":"<p>Get the total computation time (if <code>enable_timing=True</code>).</p> <p>Returns: float - Time in seconds</p> <pre><code>wc = WillardChandler(u, group=water, enable_timing=True)\nwc.assign_surface()\ntime = wc.get_timing()\nprint(f\"Computation time: {time:.4f} s\")\n</code></pre>"},{"location":"api/willard_chandler/#writevtksurfacefilename","title":"<code>writevtk.surface(filename)</code>","text":"<p>Export surface to VTK format.</p> <p>Parameters: - <code>filename</code> (str): Output file path</p> <pre><code>wc.writevtk.surface(\"surface.vtk\")\n</code></pre>"},{"location":"api/willard_chandler/#writevtkdensityfilename","title":"<code>writevtk.density(filename)</code>","text":"<p>Export density field to VTK format.</p> <pre><code>wc.writevtk.density(\"density.vtk\")\n</code></pre>"},{"location":"api/willard_chandler/#writevtkatomsfilename","title":"<code>writevtk.atoms(filename)</code>","text":"<p>Export atom positions to VTK format.</p> <pre><code>wc.writevtk.atoms(\"atoms.vtk\")\n</code></pre>"},{"location":"api/willard_chandler/#writeobjfilename","title":"<code>writeobj(filename)</code>","text":"<p>Export surface to Wavefront OBJ format.</p> <pre><code>wc.writeobj(\"surface.obj\")\n</code></pre>"},{"location":"api/willard_chandler/#writecubefilename","title":"<code>writecube(filename)</code>","text":"<p>Export density to Gaussian Cube format.</p> <pre><code>wc.writecube(\"density.cube\")\n</code></pre>"},{"location":"api/willard_chandler/#writepdbsurfacefilename","title":"<code>writepdb.surface(filename)</code>","text":"<p>Export surface vertices as PDB.</p> <pre><code>wc.writepdb.surface(\"surface.pdb\")\n</code></pre>"},{"location":"api/willard_chandler/#complete-example","title":"Complete Example","text":"<pre><code>import MDAnalysis as mda\nfrom pywc import WillardChandler\nimport numpy as np\n\n# Load trajectory\nu = mda.Universe(\"system.pdb\", \"traj.xtc\")\nlipids = u.select_atoms(\"resname DPPC and name P\")\n\n# Create WillardChandler object\nwc = WillardChandler(\n    u,\n    group=lipids,\n    alpha=3.0,\n    mesh=2.0,\n    centered=True,\n    surface_backend='cpp',\n    enable_timing=True\n)\n\n# Analyze trajectory\nareas = []\nfor ts in u.trajectory[::10]:  # Every 10th frame\n    wc.assign_surface()\n    areas.append(wc.surface_area)\n\n    # Export every 100th frame\n    if ts.frame % 100 == 0:\n        wc.writevtk.surface(f\"surface_frame_{ts.frame}.vtk\")\n\n# Statistics\nmean_area = np.mean(areas)\nstd_area = np.std(areas)\nprint(f\"Mean area: {mean_area:.2f} \u00b1 {std_area:.2f} \u0172\")\nprint(f\"Average time per frame: {wc.get_timing():.4f} s\")\n\n# Get final surface\nvertices, faces, normals = wc.triangulated_surface\nprint(f\"Final surface: {len(vertices)} vertices, {len(faces)} faces\")\n</code></pre>"},{"location":"api/willard_chandler/#see-also","title":"See Also","text":"<ul> <li>Backends - Backend selection and performance</li> <li>Quick Start - Basic usage examples</li> <li>Examples - Real-world applications</li> </ul>"}]}